"""
This module contains:

FJRWElement
    
FJRWBasisElement:
    Attributes:
        degree
        bi_grading
        
    
FJRWRing
    Methods:
        product_on_basis
        corr
        Methods for reconstruction
    Attributes:
        dual_basis
        _retry_unknown_products
        _uncertain_corrs_index

The FJRWRing class and its associated classes inherit from QuantumRing.
See the beginning of QuantumRing.py for additional explanation of the 
inheritance structure.

AUTHORS:

    - Drew Johnson (2010-2011) Initial design and implementation
    - Scott Mancuso (2012) Refactoring and documentation
    - Rachel Suggs (2012) Refactoring to inherit from existing Sage objects

"""
# if not __name__ == '__main__':  # i.e. if this is being read as a load or
                                # attach.
try:
    from sage.all import *
except ImportError:
    print("Didn't import Sage!!!")

import os
import sys
import atexit
if "." not in sys.path: sys.path.insert(0,".")

from QuantumRing import QuantumRing, QuantumRingElement, QuantumRingBasisElement
from QuantumRing import CouldNotComputeException
from SymmetryGroup import SymmetryGroup, SymmetryGroupElement
from QSingularity import QSingularity
from LazyAttr import lazy_attr
from ModuliSpace import ModuliSpace

COHOMOLOGY_ROOT = os.getenv("COHOMOLOGY_ROOT", default=os.getcwd())
CORRS_DICT_DIRECTORY = os.path.join(COHOMOLOGY_ROOT, ".corrs_db/")

if not os.path.exists(CORRS_DICT_DIRECTORY):
    os.mkdir(CORRS_DICT_DIRECTORY)

class FJRWElement(QuantumRingElement):
    """
    Class that represents an element of an FJRW ring.
    
    .. NOTE::
    
        This class inherits from :class:`QuantumRing.QuantumRingElement`; most of its
        methods and attributes are documented in that class.
    
    CONSTRUCTOR:    
    
    - ``parent`` -- The :class:`~!FJRW.FJRWRing` that this basis
      element lives in.
    - ``data`` -- A dictionary of :class:`~!FJRW.FJRWBasisElement` s and coefficients
      that describes this basis element (I think).
    
    
    .. NOTE::
        
        Users should typically not call the constructor directly. Instead they
        should create an instance of :class:`~FJRW.FJRWRing` which will populate
        a list of :class:`~FJRW.FJRWBasisElement` s.
        
    """

    def __init__(self, parent, data):
        """Constructor -- see class documentation."""
        super(FJRWElement, self).__init__(parent, data)

class FJRWBasisElement(QuantumRingBasisElement):
    """
    Class that represents a basis element of an FJRW ring.
    
    .. NOTE::
    
        This class inherits from :class:`QuantumRing.QuantumRingBasisElement`; most of its
        methods and attributes are documented in that class.
    
    CONSTRUCTOR:
    
    - ``parent_ring`` -- The :class:`~!FJRW.FJRWRing` to which this basis element belongs.
    - ``monomial`` -- The milnor ring basis element associated with this basis element.
    - ``sector`` -- A :class:`~SymmetryGroup.SymmetryGroupElement` associated to this
        basis element.
    
    .. NOTE::
    
        Elements of this class are basis elements for an FJRWRing. The user
        should not call this constructor directly. In fact, the user should never use
        instances of this class directly. Instead, all elements of an FJRWRing
        will be FJRWElements. See the documentation at the beginning of QuantumRing.py for more details.
    
    """

    def __init__(self, parent_ring, monomial, sector):
        """Constructor -- see class documentation."""
        super(FJRWBasisElement, self).__init__(parent_ring, monomial, sector)
            
    # Method deprecated - Implemented in parent instead (Julian Tay, Dec 2012)
    # @lazy_attr
    # def degree(self):
        # """
        # Return the W-degree of this :class:`~!FJRW.FJRWBasisElement`.
        
        # OUTPUT:
        
        # - A rational number giving the W-degree of this
          # :class:`~!FJRW.FJRWBasisElement`.
        
        # .. NOTE::

            # This is NOT the complex degree; this one is twice as big.
        
        # EXAMPLES:
        
            # sage: W = QSingularity.create("x^3+x*y^5+y*z^2")
            # C253
            # [z, y, x]
            # sage: G = SymmetryGroup(W, "J")
            # sage: A = FJRWRing(G)
            # FJRW ring for x^3 + x*y^5 + y*z^2 with group generated by <(2/3, 1/15, 29/30)>.
            # Dimension:   21
            # Basis:
              # [1]  e_(1/3, 2/15, 13/30)   Degree: 0     (0, 0)
              # [2]  e_(1/3, 1/3, 1/3)      Degree: 1/5   (1/10, 1/10)
              # [3]  e_(1/3, 8/15, 7/30)    Degree: 2/5   (1/5, 1/5)
              # [4]  e_(2/3, 1/15, 7/15)    Degree: 3/5   (3/10, 3/10)
              # [5]  e_(1/3, 11/15, 2/15)   Degree: 3/5   (3/10, 3/10)
              # [6]  e_(2/3, 4/15, 11/30)   Degree: 4/5   (2/5, 2/5)
              # [7]  e_(1/3, 14/15, 1/30)   Degree: 4/5   (2/5, 2/5)
              # [8]  e_(1/3, 2/15, 14/15)   Degree: 1     (1/2, 1/2)
              # [9]  e_(2/3, 7/15, 4/15)    Degree: 1     (1/2, 1/2)
            # ...
             # [21]  e_(2/3, 13/15, 17/30)  Degree: 12/5  (6/5, 6/5)
            # sage: A[2].degree
            # 1/5
            # sage: A[8].degree
            # 1
            
            # sage: W = QSingularity.create("C352")
            # sage: G = SymmetryGroup(W, "max")
            # sage: A = FJRWRing(G)
            # FJRW ring for x^3*y + y^5*z + z^2 with group generated by <(1/30, 9/10, 1/2)>.
            # Dimension:   17
            # Basis:
              # [1]  e_(3/10, 1/10, 1/2)   Degree: 0      (0, 0)
              # [2]  e_(7/30, 3/10, 1/2)   Degree: 4/15   (2/15, 2/15)
              # [3]  e_(1/6, 1/2, 1/2)     Degree: 8/15   (4/15, 4/15)
              # [4]  e_(19/30, 1/10, 1/2)  Degree: 2/3    (1/3, 1/3)
              # [5]  e_(1/10, 7/10, 1/2)   Degree: 4/5    (2/5, 2/5)
              # [6]  y^4e_(1/3, 0, 0)      Degree: 13/15  (13/30, 13/30)
              # [7]  e_(17/30, 3/10, 1/2)  Degree: 14/15  (7/15, 7/15)
              # [8]  e_(1/30, 9/10, 1/2)   Degree: 16/15  (8/15, 8/15)
              # [9]  e_(1/2, 1/2, 1/2)     Degree: 6/5    (3/5, 3/5)
            # ...
            # sage: A[8].degree
            # 16/15
            # sage: A[5].degree
            # 4/5
            
            # sage: W = QSingularity.create("C45")
            # sage: G = SymmetryGroup(W, "max")
            # sage: A = FJRWRing(G)
            # FJRW ring for x^4*y + y^5 with group generated by <(1/20, 4/5)>.
            # Dimension:   17
            # Basis:
              # [1]  e_(1/5, 1/5)    Degree: 0      (0, 0)
              # [2]  e_(3/20, 2/5)   Degree: 3/10   (3/20, 3/20)
              # [3]  e_(9/20, 1/5)   Degree: 1/2    (1/4, 1/4)
              # [4]  e_(1/10, 3/5)   Degree: 3/5    (3/10, 3/10)
              # [5]  e_(2/5, 2/5)    Degree: 4/5    (2/5, 2/5)
              # [6]  e_(1/20, 4/5)   Degree: 9/10   (9/20, 9/20)
              # [7]  e_(7/10, 1/5)   Degree: 1      (1/2, 1/2)
              # [8]  e_(7/20, 3/5)   Degree: 11/10  (11/20, 11/20)
              # [9]  x^3e_(0, 0)     Degree: 6/5    (3/5, 3/5)
             # [10]  e_(13/20, 2/5)  Degree: 13/10  (13/20, 13/20)
            # ...
            # sage: A[9].degree
            # 6/5
            # sage: A[1].degree
            # 0
        
        # """
        # weights = self.parent_ring.singularity.q
        # deg = len(self.sector.fixed)
        # for i in xrange( 0, len(weights) ):
            # deg += 2 * (self.sector[i] - weights[i])
        # return deg
        
    @lazy_attr
    def bi_degree(self):
        """
        Return the bigrading of this :class:`~!FJRW.FJRWBasisElement`.
        
        OUTPUT:
        
        - A tuple of rational numbers giving the bigrading of this
          :class:`~!FJRW.FJRWBasisElement`.
        
        .. NOTE::
        
            The calculation for the bi-grading is given on page 13 of [Kr]_.
        
        EXAMPLES:
        
            sage: W = QSingularity.create("C73(10)")
            sage: G = SymmetryGroup(W,"J")
            sage: A = FJRWRing(G)
            FJRW ring for x^7*y + y^3*z + z^10 with group generated by <(1/10, 3/10, 1/10)>.
            Dimension:   27
            Basis:
              [1]  e_(1/10, 3/10, 1/10)    Degree: 0  (0, 0)
              [2]  e_(1/5, 3/5, 1/5)       Degree: 1  (1/2, 1/2)
              [3]  e_(2/5, 1/5, 2/5)       Degree: 1  (1/2, 1/2)
              [4]  z^5e_(0, 0, 0)          Degree: 2  (1/2, 3/2)
              [5]  y*z^2e_(0, 0, 0)        Degree: 2  (1/2, 3/2)
              [6]  x*z^4e_(0, 0, 0)        Degree: 2  (1/2, 3/2)
              [7]  x*y*ze_(0, 0, 0)        Degree: 2  (1/2, 3/2)
              [8]  x^2*z^3e_(0, 0, 0)      Degree: 2  (1/2, 3/2)
              [9]  x^2*ye_(0, 0, 0)        Degree: 2  (1/2, 3/2)
             [10]  x^3*z^2e_(0, 0, 0)      Degree: 2  (1/2, 3/2)
             [11]  x^4*ze_(0, 0, 0)        Degree: 2  (1/2, 3/2)
             [12]  x^5e_(0, 0, 0)          Degree: 2  (1/2, 3/2)
             [13]  e_(3/10, 9/10, 3/10)    Degree: 2  (1, 1)
             [14]  e_(1/2, 1/2, 1/2)       Degree: 2  (1, 1)
             [15]  e_(7/10, 1/10, 7/10)    Degree: 2  (1, 1)
             [16]  y^2*z^9e_(0, 0, 0)      Degree: 2  (3/2, 1/2)
             [17]  x*y^2*z^8e_(0, 0, 0)    Degree: 2  (3/2, 1/2)
            ...
            sage: A[12].bi_degree
            (1/2, 3/2)
            sage: A[13].bi_degree
            (1, 1)
            sage: A[16].bi_degree
            (3/2, 1/2)

        
        """
        p_degree = 0
        m_degree = 0
        weights = self.parent_ring.Gsec.poly.q
        group_elem = self.sector
        
        for n in group_elem.not_fixed:
            p_degree += group_elem[n] - weights[n]
            m_degree += group_elem[n] - weights[n]
        for n in group_elem.fixed:
            m_degree += 1 - 2 * weights[n]
            
        try:
            # Add weighted degree of monomial.
            weighted_degree = sum([e * q for (e, q) in
                                   zip(self.monomial.exponents()[0],
                                       weights)])
        except AttributeError:
            # If there was an attribute error, assume it was because the
            # monomial was 1, in which case the weighted degree was 0.
            weighted_degree = 0
        
        p_degree += weighted_degree
        m_degree -= weighted_degree
        
        return (p_degree, m_degree)


class FJRWRing(QuantumRing):
    """
    Class that stores infomation about the FJRW ring for a given polynomial and
    group. It also contains methods for computing correlators.
    
    .. NOTE::
    
        This class inherits from :class:`QuantumRing.QuantumRing`; most of its
        methods and attributes are documented in that class.
    
    CONSTRUCTOR:

    - ``Gsec`` -- The :class:`~SymmetryGroup.SymmetryGroup` that will create the
      sectors.
    - ``Ginv`` -- The :class:`~SymmetryGroup.SymmetryGroup` to take invariants
      by. This is a special feature; typically one can leave it blank and then
      it will be set equal to ``Gsec``.
    - ``print_basis`` -- Set this to ``True`` if you want a summary of the state
      space printed immediately after construction. Defaults to ``True``.
    - ``R`` -- The base ring of this algebra. Must be a field. Defaults to "QQ".
    - ``prefix`` -- A string that is the name of this ring. Defaults to "H".
    - ``basis_element_repr`` -- A string used when printing out basis elements 
      of this class. Defaults to "e".
    
    
    Member Options:
    
    - ``VERBOSE_MUL`` -- Set this to ``True`` if you want lots of output when
      you compute a multiplication. Defaults to ``False``.

    EXAMPLES:
    
    First, create the necessary objects. Here we use the singularity `P_8 = x^3
    + y^3 + z^3`, with `G^{max}`::
    
        sage: W = QSingularity.create("F333")
        sage: G = SymmetryGroup(W, "max")

    Now construct the FJRW ring. The object `G` remembers `W`, so just pass in
    `G`::
    
        sage: H = FJRWRing(G)
        FJRW ring for x^3 + y^3 + z^3 with group generated by <(0, 0, 1/3), (0,
        1/3, 0), (1/3, 0, 0)>.
        Dimension:   8
        Basis:
          [1]  e_(1/3, 1/3, 1/3)  Degree: 0    (0, 0)
          [2]  e_(2/3, 1/3, 1/3)  Degree: 2/3  (1/3, 1/3)
          [3]  e_(1/3, 2/3, 1/3)  Degree: 2/3  (1/3, 1/3)
          [4]  e_(1/3, 1/3, 2/3)  Degree: 2/3  (1/3, 1/3)
          [5]  e_(2/3, 2/3, 1/3)  Degree: 4/3  (2/3, 2/3)
          [6]  e_(2/3, 1/3, 2/3)  Degree: 4/3  (2/3, 2/3)
          [7]  e_(1/3, 2/3, 2/3)  Degree: 4/3  (2/3, 2/3)
          [8]  e_(2/3, 2/3, 2/3)  Degree: 2    (1, 1)

    Use ``[ ]`` to access basis elements by index::
    
        sage: a = H[2]; a
        e_(2/3, 1/3, 1/3)
        sage: b = H[3]; b
        e_(1/3, 2/3, 1/3)

    You can multiply basis elements::
    
        sage: a*b
        e_(2/3, 2/3, 1/3)

    Vector space operations are supported::
    
        sage: c = 8*a + 5*b; c
        8*e_(2/3, 1/3, 1/3) + 5*e_(1/3, 2/3, 1/3)
    
    You can also access elements by their names. The name must be typed exactly
    as it appears in the list::
    
        sage: d = H["e_(1/3, 1/3, 2/3)"]; d
        e_(1/3, 1/3, 2/3)
    
    Multiply a general vector space element by a basis element::
    
        sage: c * d
        8*e_(2/3, 1/3, 2/3) + 5*e_(1/3, 2/3, 2/3)
    
    The orbifold group must contain ``J``, the exponential grading operator::
    
        sage: Gbad = SymmetryGroup(W, 0)
        sage: Hbad = FJRWRing(Gbad)
        Traceback (most recent call last):
        ...
        ValueError: The orbifold group must contain J!
    
    You can modify the way the ring prints using the inputs `prefix` and `basis_element_repr`::
    
        sage: W = QSingularity.create("F5")
        sage: G = SymmetryGroup(W, "J")
        sage: A = FJRWRing(G, prefix = "A", basis_element_repr = "a")
        FJRW ring for x^5 with group generated by <(1/5,)>.
        Dimension:   4
        Basis:
          [1]  a_(1/5,)  Degree: 0    (0, 0)
          [2]  a_(2/5,)  Degree: 2/5  (1/5, 1/5)
          [3]  a_(3/5,)  Degree: 4/5  (2/5, 2/5)
          [4]  a_(4/5,)  Degree: 6/5  (3/5, 3/5)
        sage: print A[1]
        A[1]
    
    Symbolic Ring can also be used as a coefficient field. Be aware, however, that QQbar, RR, and CC will cause errors::
    
        sage: W = QSingularity.create("F3")
        sage: G = SymmetryGroup(W, "J")
        sage: A = FJRWRing(G, R=SR)
        FJRW ring for x^3 with group generated by <(1/3,)>.
        Dimension:   2
        Basis:
          [1]  e_(1/3,)  Degree: 0    (0, 0)
          [2]  e_(2/3,)  Degree: 2/3  (1/3, 1/3)
        sage: sqrt(2)*A[1]
        sqrt(2)*e_(1/3,)
        sage: var('a'); a*A[1]
        a
        a*e_(1/3,)
        
    Here are three examples of FJRW (A - Model) state space computations    
        
        sage: W = QSingularity.create("C37")
        sage: G = SymmetryGroup(W, "max")
        sage: A = FJRWRing(G)
        FJRW ring for x^3*y + y^7 with group generated by <(1/21, 6/7)>.
        Dimension:   19
        Basis:
          [1]  e_(2/7, 1/7)    Degree: 0      (0, 0)
          [2]  e_(5/21, 2/7)   Degree: 4/21   (2/21, 2/21)
          [3]  e_(4/21, 3/7)   Degree: 8/21   (4/21, 4/21)
          [4]  e_(1/7, 4/7)    Degree: 4/7    (2/7, 2/7)
          [5]  e_(13/21, 1/7)  Degree: 2/3    (1/3, 1/3)
          [6]  e_(2/21, 5/7)   Degree: 16/21  (8/21, 8/21)
          [7]  e_(4/7, 2/7)    Degree: 6/7    (3/7, 3/7)
          [8]  e_(1/21, 6/7)   Degree: 20/21  (10/21, 10/21)
          [9]  e_(11/21, 3/7)  Degree: 22/21  (11/21, 11/21)
         [10]  x^2e_(0, 0)     Degree: 8/7    (4/7, 4/7)
         [11]  e_(10/21, 4/7)  Degree: 26/21  (13/21, 13/21)
         [12]  e_(20/21, 1/7)  Degree: 4/3    (2/3, 2/3)
         [13]  e_(3/7, 5/7)    Degree: 10/7   (5/7, 5/7)
         [14]  e_(19/21, 2/7)  Degree: 32/21  (16/21, 16/21)
         [15]  e_(8/21, 6/7)   Degree: 34/21  (17/21, 17/21)
         [16]  e_(6/7, 3/7)    Degree: 12/7   (6/7, 6/7)
         [17]  e_(17/21, 4/7)  Degree: 40/21  (20/21, 20/21)
         [18]  e_(16/21, 5/7)  Degree: 44/21  (22/21, 22/21)
         [19]  e_(5/7, 6/7)    Degree: 16/7   (8/7, 8/7)
         
        sage: W = QSingularity.create("C342")
        sage: G = SymmetryGroup(W, "J")
        sage: A = FJRWRing(G)
        FJRW ring for x^3*y + y^4*z + z^2 with group generated by <(1/24, 7/8, 1/2)>.
        Dimension:   14
        Basis:
          [1]  e_(7/24, 1/8, 1/2)   Degree: 0    (0, 0)
          [2]  e_(5/24, 3/8, 1/2)   Degree: 1/3  (1/6, 1/6)
          [3]  e_(1/8, 5/8, 1/2)    Degree: 2/3  (1/3, 1/3)
          [4]  e_(5/8, 1/8, 1/2)    Degree: 2/3  (1/3, 1/3)
          [5]  y^3e_(1/3, 0, 0)     Degree: 5/6  (5/12, 5/12)
          [6]  e_(1/24, 7/8, 1/2)   Degree: 1    (1/2, 1/2)
          [7]  e_(13/24, 3/8, 1/2)  Degree: 1    (1/2, 1/2)
          [8]  e_(11/24, 5/8, 1/2)  Degree: 4/3  (2/3, 2/3)
          [9]  e_(23/24, 1/8, 1/2)  Degree: 4/3  (2/3, 2/3)
         [10]  y^3e_(2/3, 0, 0)     Degree: 3/2  (3/4, 3/4)
         [11]  e_(3/8, 7/8, 1/2)    Degree: 5/3  (5/6, 5/6)
         [12]  e_(7/8, 3/8, 1/2)    Degree: 5/3  (5/6, 5/6)
         [13]  e_(19/24, 5/8, 1/2)  Degree: 2    (1, 1)
         [14]  e_(17/24, 7/8, 1/2)  Degree: 7/3  (7/6, 7/6)
         
        sage: W = QSingularity.create("C93","yx")
        sage: G = SymmetryGroup(W, "max")
        sage: A = FJRWRing(G)
        FJRW ring for y^9*x + x^3 with group generated by <(1/27, 2/3)>.
        Dimension:   19
        Basis:
          [1]  e_(2/27, 1/3)   Degree: 0      (0, 0)
          [2]  e_(5/27, 1/3)   Degree: 2/9    (1/9, 1/9)
          [3]  e_(8/27, 1/3)   Degree: 4/9    (2/9, 2/9)
          [4]  e_(1/27, 2/3)   Degree: 16/27  (8/27, 8/27)
          [5]  e_(11/27, 1/3)  Degree: 2/3    (1/3, 1/3)
          [6]  e_(4/27, 2/3)   Degree: 22/27  (11/27, 11/27)
          [7]  e_(14/27, 1/3)  Degree: 8/9    (4/9, 4/9)
          [8]  e_(7/27, 2/3)   Degree: 28/27  (14/27, 14/27)
          [9]  e_(17/27, 1/3)  Degree: 10/9   (5/9, 5/9)
         [10]  y^8e_(0, 0)     Degree: 32/27  (16/27, 16/27)
         [11]  e_(10/27, 2/3)  Degree: 34/27  (17/27, 17/27)
         [12]  e_(20/27, 1/3)  Degree: 4/3    (2/3, 2/3)
         [13]  e_(13/27, 2/3)  Degree: 40/27  (20/27, 20/27)
         [14]  e_(23/27, 1/3)  Degree: 14/9   (7/9, 7/9)
         [15]  e_(16/27, 2/3)  Degree: 46/27  (23/27, 23/27)
         [16]  e_(26/27, 1/3)  Degree: 16/9   (8/9, 8/9)
         [17]  e_(19/27, 2/3)  Degree: 52/27  (26/27, 26/27)
         [18]  e_(22/27, 2/3)  Degree: 58/27  (29/27, 29/27)
         [19]  e_(25/27, 2/3)  Degree: 64/27  (32/27, 32/27)

         
    
    AUTHORS:
    
    - Drew Johnson (2010-2011)
    
      - Initial implementation
    
    - Scott Mancuso (2012)
    
      - Use of :attr:`~FJRW.FJRWRing._corrs_dict_dict` to save and load computed
        correlators
      - Documentation
    
    - Amanda Francis (2012)
    
      - Reconstruction methods
    
    """
    VERBOSE_MUL = False
    """A boolean describing the level of output desired when computing
    multiplications. Set this to ``True`` if you want lots of output when you
    compute a multiplication. Defaults to ``False``."""
    Element = FJRWElement
    """An alias for the class of elements of this ring."""
    _ring_type = "FJRW ring"
    """A string describing the type of ring that this is."""
    _my_basis_element = FJRWBasisElement
    """An alias for the class of basis elements of this ring."""

    def __init__(self, Gsec, Ginv="default", print_basis = True, R = QQ, prefix = "H", basis_element_repr = "e"):
        """Constructor -- see class documentation."""
        self._retry_unknown_products = False
        """A boolean value that determines whether or not we should try to
        compute products that we already tried and couldn't compute. Defaults to
        ``False``."""
        self._uncertain_corrs_index = 0
        """An integer value to keep track of how many correlators have been
        computed for which we used the Witten map and could only compute the
        value up to a factor of -1. Used as the subscript on the variable
        representing (+-)1. BUT, in this version of the code we got rid of that
        variable. This index now just counts the number of uncertain correlators."""

        if not Gsec.containsJ():
            raise ValueError( "The orbifold group must contain J!")
        super(FJRWRing, self).__init__(Gsec, Ginv, print_basis, R, prefix, basis_element_repr)

        self.corr_dict = dict()
        self.corrs_calculated = []
        """A list of integers giving the correlators that have already been
        calculated, i.e. if k is in corrs_calculated, then all of the k-point
        correlators have been computed and stored in corr_dict."""
        
        # Load or create a dictionary to store correlators that we've already
        # computed.
        # This feature added by Scott Mancuso, May 2012.
        try:
            self._corrs_dict_dict = load(os.path.join(
                                            CORRS_DICT_DIRECTORY,
                                            "%s" % self._file_safe_repr()))
            """A dictionary of dictionaries. The key ``(g, k)`` is a tuple with
            the genus and the number of insertions, and the value is a
            dictionary. In this second dictionary, the key is a tuple of ``k``
            integers givning the index of the basis elements of ``self``
            included in this correlator, and the value is the value of their
            genus ``g`` correlator. Thus ``_corrs_dict_dict[(0, 3)][(1, 2, 3)]``
            would give you the value of the 3-point-correlator of the first
            three basis elements of the :class:`~FJRW.FJRWRing` ``H``. Also
            contains a special entry ``"index"`` which contains the last value
            of :attr:`~FJRW.FJRWRing._uncertain_corrs_index`. """
            self._uncertain_corrs_index = self._corrs_dict_dict["index"]
        except IOError:
            # We've never created this ring before.
            self._corrs_dict_dict = {"index":self._uncertain_corrs_index}
        except KeyError:
            # 'index' had never been saved before.
            for corrs_dict in self._corrs_dict_dict.values():
                for val in corrs_dict.values():
                    # Only count symbolic values, not numbers or exceptions.
                    if val in SR and val not in RR:
                        self._uncertain_corrs_index += 1
            self._corrs_dict_dict["index"] = self._uncertain_corrs_index
        
        # Hash the values of this dictionary. We'll only re-save it if it
        # changes; however, we don't want to lug around an extra copy of the
        # entire dictionary.
        self._corrs_hash = sum([hash(tuple(cdict.values())) for cdict in
                                self._corrs_dict_dict.values() if
                                isinstance(cdict, dict)])
        self._corrs_hash += self._corrs_dict_dict["index"]
        
        if self._inside_doctest():
            # Don't modify the saved values if run by a doctest.
            self._uncertain_corrs_index = 0
            self._corrs_dict_dict_orig = self._corrs_dict_dict
            self._corrs_dict_dict = {"index":self._uncertain_corrs_index}
            # Check to make sure the newly computed values don't conflict with
            # the previously saved values.
            atexit.register(self._verify_corrs)
        elif not self._inside_timeit():
            # Make sure to update the saved files when we close Sage.
            atexit.register(self._update_corrs_file)
    
    def _update_corrs_file(self):
        """
        Update the saved file to reflect recently computed correlators. If
        called from inside a doctest or timing function, or if no new
        correlators have been computed since this ring was created, it simply
        exits without updating the saved file. Doesn't return a value.
        
        .. TODO::
        
            Add tests.
        
        AUTHOR:
        
        - Scott Mancuso (June 2012)
        
        """
        corrs_hash = sum([hash(tuple(cdict.values())) for cdict in
                           self._corrs_dict_dict.values() if
                           isinstance(cdict, dict)])
        corrs_hash += self._corrs_dict_dict["index"]
        if self._corrs_hash == corrs_hash:
            # `corrs_dict_dict` hasn't changed, so don't save it again.
            return
        else:
            self._corrs_hash = corrs_hash
        if self._inside_doctest() or self._inside_timeit():
            return
        save(self._corrs_dict_dict, os.path.join(CORRS_DICT_DIRECTORY,
                                                "%s" % self._file_safe_repr()))
        print("Correlators updated.")

    def product_on_basis(self, x, y):
        """
        Return the product of ``x`` and ``y``.
        
        INPUT:
        
        - ``a, b`` -- Two :class:`~!FJRW.FJRWBasisElement` s that are in the basis of self.
        
        OUTPUT:
        
        - The value of the product of ``x`` and ``y``.
        
        .. NOTE::
            
            This method is called by the method :meth:`~QuantumRing.QuantumRing.pair`.
            It should not be called directly by the user.
        
        .. TODO::
        
            Add tests.
        
        AUTHORS:
        
        - Drew Johnson (2010-2011) Initial implementation
        - Scott Mancuso (2012) Use of
          :attr:`~QuantumRing.QuantumRing._products_dict` to save and load
          computed products
        
        """
        indices = tuple(sorted((x.index, y.index)))
        # Has the value already been computed?
        try:
            if self.VERBOSE_MUL:
                raise KeyError  # This is so we go into the next except
                                # statement.
            value = self._products_dict[indices]
            raise KeyError
            try:
                # See if value is an exception instead of an AlgebraElem.
                raise value
            except TypeError:
                pass
            except CouldNotComputeException:
                if self._retry_unknown_products:
                    raise KeyError  # This is so we go into the next except
                                    # statement.
                else:
                    raise
        except KeyError:
            value = self.zero()
            mu2 = self.dimension()
            eta_inv = self.eta_inv
            
            
            # For simplicity's sake, we want all three arguments of
            # the correlator to be FJRWElements. We choose this
            # over FJRWBasisElements since the correlator can be called
            # from the command line with these elements.
            # The following converts x and y to FJRWBasisElements.
            x = self.basis()[x]
            y = self.basis()[y]
            
            for i in range(0, mu2):
                #try:
                rsa = self.corr([x, y, self.list()[i]],
                                           self.VERBOSE_MUL)
                #except (CouldNotComputeException, X):
                #    self._products_dict[indices] = X
                #    raise X
                if rsa != 0:
                    for j in range(0, mu2):
                        if eta_inv[i, j] != 0:
                            value += rsa*eta_inv[i, j]*self.list()[j]
            
            # Record this product.
            self._products_dict[indices] = value
        
        return value
        
    @lazy_attr
    def dual_basis(self):
        """
        Return a list of elements that is dual to the basis stored here.
        
        .. TODO::
        
            Figure out what the purpose of this method is and what it's good 
            for.
        
        EXAMPLES::
        
            sage: H = FJRWRing(SymmetryGroup(QSingularity.create("L34"), "max"))
            FJRW ring for x^3*y + x*y^4 with group generated by <(1/11, 8/11)>.
            Dimension:   12
            Basis:
              [1]  e_(3/11, 2/11)   Degree: 0     (0, 0)
              [2]  e_(2/11, 5/11)   Degree: 4/11  (2/11, 2/11)
              [3]  e_(7/11, 1/11)   Degree: 6/11  (3/11, 3/11)
              [4]  e_(1/11, 8/11)   Degree: 8/11  (4/11, 4/11)
              [5]  e_(6/11, 4/11)   Degree: 10/11 (5/11, 5/11)
              [6]  y^3e_(0, 0)      Degree: 12/11 (6/11, 6/11)
              [7]  x^2e_(0, 0)      Degree: 12/11 (6/11, 6/11)
              [8]  e_(5/11, 7/11)   Degree: 14/11 (7/11, 7/11)
              [9]  e_(10/11, 3/11)  Degree: 16/11 (8/11, 8/11)
             [10]  e_(4/11, 10/11)  Degree: 18/11 (9/11, 9/11)
             [11]  e_(9/11, 6/11)   Degree: 20/11 (10/11, 10/11)
             [12]  e_(8/11, 9/11)   Degree: 24/11 (12/11, 12/11)
            
            sage: matrix(H.dimension(), lambda i, j: H.pair(H[i + 1],
            ...   H.dual_basis[j])).is_one()
            True
            
        """
        dbasis = [self.zero()] * self.dimension()
        for i in range(self.dimension()):
            vect = self.eta_inv.column(i)
            for j in range(len(vect)):
                dbasis[i] = dbasis[i] + vect[j] * self[j + 1]
        return dbasis
            
    def corr(self, a, verbose=False, g=0, deg_Witten_already_tried=None,
             shortcut=False):
        """
        Lookup or calculate the value of the correlator of the passed in
        :class:`~FJRW.FJRWBasisElement` s.
        
        INPUT:
         
        - ``a`` -- A list of :class:`~!FJRW.FJRWBasisElement` s.
        - ``verbose`` -- Set this to ``True`` to get output about which axiom
          was used. Defaults to ``False``.
        - ``g`` -- The genus of the correlator. Defaults to 0.
        - ``deg_Witten_already_tried`` -- Used to prevent infinite recursion.
          The user shouldn't use this option. Defaults to ``None``.
        - ``shortcut`` -- Set this to ``False`` to use long methods instead of
          short ones (ModuliSpace tricks). Defaults to ``False``.
        
        OUTPUT:
        
        - The (complex number) value of the correlator.
        
        .. NOTE::
            
            Support for correlators other than genus 0 with 3 insertions is
            quite limited.
            
        Here is the example from the Priddis et al. paper::
        
            sage: E19 = QSingularity.create("RC37", "xy")
            sage: G = SymmetryGroup(E19, "max")
            sage: H = FJRWRing(G)
            FJRW ring for x^3 + x*y^7 with group generated by <(2/3, 1/21)>.
            Dimension:   15
            Basis:
              [1]  e_(1/3, 2/21)   Degree: 0     (0, 0)
              [2]  e_(1/3, 5/21)   Degree: 2/7   (1/7, 1/7)
              [3]  e_(2/3, 1/21)   Degree: 4/7   (2/7, 2/7)
              [4]  e_(1/3, 8/21)   Degree: 4/7   (2/7, 2/7)
              [5]  e_(2/3, 4/21)   Degree: 6/7   (3/7, 3/7)
              [6]  e_(1/3, 11/21)  Degree: 6/7   (3/7, 3/7)
              [7]  y^6e_(0, 0)     Degree: 8/7   (4/7, 4/7)
              [8]  e_(2/3, 1/3)    Degree: 8/7   (4/7, 4/7)
              [9]  e_(1/3, 2/3)    Degree: 8/7   (4/7, 4/7)
             [10]  e_(2/3, 10/21)  Degree: 10/7  (5/7, 5/7)
             [11]  e_(1/3, 17/21)  Degree: 10/7  (5/7, 5/7)
             [12]  e_(2/3, 13/21)  Degree: 12/7  (6/7, 6/7)
             [13]  e_(1/3, 20/21)  Degree: 12/7  (6/7, 6/7)
             [14]  e_(2/3, 16/21)  Degree: 2     (1, 1)
             [15]  e_(2/3, 19/21)  Degree: 16/7  (8/7, 8/7)

            sage: H.corr([H[1], H[2], H[4]], True)
            Computing <e_(1/3, 2/21), e_(1/3, 5/21), e_(1/3, 8/21)>...
            Dimension is -5/7 -- not in 2Z. Correlator vanishes.
            0

            sage: H.corr([H[1], H[7], H[7]], True)
            Computing <e_(1/3, 2/21), y^6e_(0, 0), y^6e_(0, 0)>...
            pairing
            -1/7

            sage: H.corr([H[2], H[1], H[14]], True)
            Computing <e_(1/3, 5/21), e_(1/3, 2/21), e_(2/3, 16/21)>...
            1 by concavity axiom
            1

        The Index 0 trick::
        
            sage: H.corr([H[7], H[3], H[3]], True)
            Computing <y^6e_(0, 0), e_(2/3, 1/21), e_(2/3, 1/21)>...
            Did some Witten map stuff:  1
            Warning... computed the correlator <H[3], H[3], H[7]> up to a factor
            of -1
            1
            
        """
        # Set how many insertions are being used for this correlator.
        k = len(a)
        # A tuple describing what kind of correlator we're looking for.
        corr_type = (g, k)
        # Want an immutable version of `a` that we can use as a dictionary key.
        key_a = tuple(sorted([elem.index for elem in a]))
        try:
            current_dict = self._corrs_dict_dict[corr_type]
        except KeyError:
            # We haven't computed any correlators with `k` insertions of genus
            # `g` yet.
            self._corrs_dict_dict[corr_type] = {}
            current_dict = self._corrs_dict_dict[corr_type]
        else:
            try:
                return_value = current_dict[key_a]
                try:
                    # See if it is an exception instead of a value.
                    raise return_value
                except TypeError:
                    pass
            except KeyError:
                # We haven't yet computed this correlator.
                pass
            else:
                # Previously computed values don't store messages, so only
                # use them if additional information isn't requested.
                if not verbose:
                    return return_value
                else:
                    # Store the previous value to compare at the end. This is
                    # only currently used to make sure that, once we've assigned
                    # a variable name to a certain correlator value, we keep
                    # using that same name every time we compute it.
                    previously_computed_value = return_value
        
        def vprint(message):
            if verbose:
                print(message)
               
        if deg_Witten_already_tried is not None:
            aset = frozenset(a)
            if any([aset == b for b in deg_Witten_already_tried]):
                X = CouldNotComputeException(
                        "Failed to compute correlator... index 0 trick was "
                        "probably going into infinite recursion.")
                current_dict[key_a] = X
                raise X

        vprint("Computing <" + str(a)[1:-1] + ">...")

        if self.forced_zero(a, verbose=verbose, g=g):
            current_dict[key_a] = 0
            return 0

        l = self.line_bundle_degrees(a=a, g=g)

        
#   --Concavity Axiom--
        all_negative = true
        for j in range(self.singularity.nvariables):
             if l[j] >= 0:
                  all_negative = false
        narrow = True
        for elem in a:
            if not elem.is_narrow:
                narrow = False
        if all_negative and narrow:
            if k == 3 and g == 0:
                vprint("1 by concavity axiom")
                current_dict[key_a] = 1
                return 1
            elif k == 4 and g == 0 and shortcut is True:
                Mbar = ModuliSpace(self, a)
                if Mbar.all_boundary_concave(verbose=verbose) is False:
                    pass
                
                else:
                    vprint("The concavity axiom applies, g = 0, n = 4")
                    vprint("Chiodo's formula (Thm 1.1.1):")
                    q = self.singularity.q
                    J = self[1].sector
                    ga1 = J - a[0].sector - a[1].sector
                    ga2 = J - a[0].sector - a[2].sector
                    ga3 = J - a[0].sector - a[3].sector
                    LB = self.line_bundle_degrees(a)
                    newgpelems = [ga1, ga2, ga3]
                    
                    for r in range(len(LB)):
                        for m in range(3):
                            lbbdry = (J[r] - a[0].sector[r] - a[m + 1].sector[r] -
                                      newgpelems[m][r])
                            if lbbdry == 0 or lbbdry == LB[r] - 1:
                                applies = False
                                
                    bersumtotal = 0
                    for i in range(len(q)):
                        bersum = q[i] * (q[i] - 1)
                        for j in range(len(a)):
                            bersum -= a[j].sector[i] * (a[j].sector[i] - 1)
                        bersum += (ga1[i] * (ga1[i] - 1) + ga2[i] * (ga2[i] - 1)
                                   + ga3[i] * (ga3[i] - 1))
                        bersumtotal += bersum / 2
                        
                    # Multiply by (-1)^D for D = 1.
                    try:
                        # Convert answer to a rational if possible for storage purposes
                        current_dict[key_a] = QQ(bersumtotal)
                    except ValueError:
                        # In this case we couldn't convert bersumtotal to a rational
                        current_dict[key_a] = bersumtotal
                    return bersumtotal
                    
            elif g == 0:
                Mbar = ModuliSpace(self, a, g)
                if Mbar.all_boundary_concave(verbose=verbose) is True:
                    vprint("The concavity axiom applies, g = 0, n = %s"
                           % str(k))
                    #: Needs to be tested.
                    return_value = Mbar.correlator(verbose)
                    try:
                        # Convert answer to a rational if possible for storage purposes
                        current_dict[key_a] = QQ(return_value)
                    except ValueError:
                        # In this case we couldn't convert return_value to a rational
                        current_dict[key_a] = return_value
                    return return_value
                    
            else:
                if self.RRD(a) != 3 * g - 3 + k:
                    vprint("RRD, dimension don't match")
                    current_dict[key_a] = 0
                    return 0
                else:
                    print("The concavity axiom applies here, but is not "
                           "implemented yet.")
                    print("g = %s, n = %s" % (str(g), str(k)))
                
        if k == 3 and g == 0:

#   --Pairing Axiom--
            for i in range(k):
                if a[i].is_one():
                    vprint("pairing")
                    return_value = self.pair(a[(i + 1) % 3], a[(i + 2) % 3])
                    try:
                        # If possible, convert to answer to a rational for storage purposes
                        current_dict[key_a] = QQ(return_value)
                    except ValueError:
                        # In this case, we couldn't convert the answer to a rational
                        current_dict[key_a] = return_value
                    return return_value

#   --Index Zero Axiom
            #vprint("doing index 0")
            
            if deg_Witten_already_tried is None:
                deg_Witten_already_tried = [frozenset(a)]
            else:
                deg_Witten_already_tried.append(frozenset(a))
                
            # Attempts to use the trick in Priddis et. al.
            for out in range(0, 3):  # Try leaving one thing out.
                #vprint("leaving out"+str(a[out]) )
                degWit = self._deg_Witton([a[(out + 1) % 3], a[(out + 2) % 3],
                                           a[(out + 1) % 3], a[(out + 2) % 3]])
                if degWit is not None:
                    #vprint("This wasn't broadish"+str(a[(out + 1) % 3])+str(a[(out + 2) % 3]) )
                    sum = degWit
                    for alpha, i in zip(self.list(),
                                        range(0, self.dimension() )):
                        for beta, j in zip(self.list(),
                                           range(0, self.dimension() )):
                            if (alpha == a[out] and beta == a[out]):
                                    continue
                            if self.eta_inv[i, j] != 0:
                                try:
                                    corr1 = self.corr(
                                            [a[(out + 1) % 3],
                                             a[(out + 2) % 3], alpha],
                                            deg_Witten_already_tried =
                                            deg_Witten_already_tried)
                                except CouldNotComputeException:
                                    corr1 = None
                                    
                                try:
                                    corr2 = self.corr(
                                            [beta, a[(out + 1) % 3],
                                                   a[(out + 2) % 3]],
                                            deg_Witten_already_tried =
                                            deg_Witten_already_tried)
                                except CouldNotComputeException:
                                    corr2 = None
                                    
                                if corr1 is not None and corr2 is not None:
                                    sum -=  corr1 * self.eta_inv[i, j] * corr2
                                if ((corr1 is None and corr2 != 0) or
                                    (corr2 is None and corr1 != 0)):
                                    X = CouldNotComputeException(
                                            "Index 0 trick fails")
                                    current_dict[key_a] = X
                                    raise X

                    # Line 1
                    return_value = sqrt(
                           sum / self.eta_inv[a[out].index-1,
                                              a[out].index-1] )
                    vprint("Did some Witten map stuff:  %s"
                           % str(return_value))
                    print("Warning... computed the correlator <%s> up to a "
                          "factor of -1"
                          % ", ".join([str(elem) for elem in sorted(a)]))
                    self._uncertain_corrs_index += 1
                    ###########################################
                    # ..TODO:: We need to add a method .base_extend to QuantumRing in
                    # order to enable the code to handle things like this. 
                    ###########################################
                    #cur_var_name = "a%d" % self._uncertain_corrs_index
                    #plus_minus_one = SR.symbol(cur_var_name)
                    #return_value *= plus_minus_one
                    ############################################
                    # Check if we'd already assigned a value to this corr, and
                    # make sure it's the same.
                    try:
                        prev_val = previously_computed_value
                    except NameError:
                        pass
                    # We only get here if verbose=True and we've previously computed this correlator
                    else:
                        if prev_val not in SR or (SR(prev_val).coeffs() !=
                                                  return_value.coeffs()):
                            print >> sys.stderr, (
                                    "Warning... a different value was "
                                    "previously computed for this correlator.")
                            print >> sys.stderr, "Previous value:", prev_val
                            print >> sys.stderr, "New value:", return_value
                            print >> sys.stderr, "Which value is correct? (p/n)"
                            while True:
                                sleep(.1)
                                which_value = raw_input().lower()
                                if which_value == "p":
                                    return_value = prev_val
                                    break
                                elif which_value == "n":
                                    break
                        else:
                            # We ended up not needing a new variable name.
                            self._uncertain_corrs_index -= 1
                            return_value = prev_val
                            
                    try:
                        # If possible, convert to answer to a rational for storage purposes
                        current_dict[key_a] = QQ(return_value)
                    except ValueError:
                        # In this case, we couldn't convert the answer to a rational
                        current_dict[key_a] = return_value
                    return return_value
            

        X = CouldNotComputeException("The correlator could not be "
                                     "computed for <%s>" % str(a)[1:-1])
        current_dict[key_a] = X
        raise X


    def _deg_Witton(self, a, verbose=False, g=0):
        """
        Determine if the index zero Axiom applies and return the degree of the
        Witten map if it does. Only works in special cases similar to those in
        Priddis et. al.
        
        .. TODO::
        
            Needs to be tested.
            
        INPUT:
        
        - ``a`` -- A list of :class:`~FJRW.FJRWBasisElement` s.
        - ``verbose`` -- Set to ``True`` to get output. Defaults to ``False``.
        - ``g`` -- The genus of the correlator. Defaults to 0.

        OUTPUT:
        
        - ``None`` if the index zero axiom does not apply; the degree
          of the Witten map if it does.
        
        .. TODO::
        
            Check that N = self.Gsec.length is right.
            
        """
        def vprint(message):
            if verbose:
                print(message)

        for ai in a:
            if not ai.is_narrow:
                return None

        k = len(a)
        l = self.line_bundle_degrees(a, g)
        # Not sure about this!!!  TODO check that this is right...
        N = self.Gsec.length

        h0 = []
        h1 = []
        
        for i in range(0, N):
            if l[i] < 0:
                h0.append(0)
                h1.append(-l[i] - 1)
                if not (h1[i] == 0 or h1[i] == 1):
                    vprint("h^1_" + str(i) + " = " + str(h1[i]) + ". I don't "
                           "know how to do that!")
                    return None
            else:
                h0.append(l[i] + 1)
                if not (h0[i] == 0 or h0[i] == 1):
                    vprint("h^0_" + str(i) + " = " + str(h0[i]) + ". I don't "
                           "know how to do that!")
                    return None
                h1.append(0)

        evalat = []
        for i in range(0, N):
            if h0[i] == 1:
                evalat.append(self.singularity.poly.variables()[i])
            else:
                evalat.append(0)

        degWitten = 1
        for i in range(0, N):
            if h1[i] == 1:
                Wm = self.singularity.poly.derivative(
                        self.singularity.poly.variables()[i])
                Wm = Wm(evalat)
                degWitten *= -Wm.degree()

        return degWitten

    def forced_zero(self, a, verbose=False, g=0):
        """
        Determine if any of the easy to check selection rules apply to the
        genus ``g`` correlator. This method checks the Dimension Axiom, the
        Integer Line bundle degrees Axiom, and the invariance under the action
        of `G^{max}` property. Also returns ``True`` if the correlator
        contains the identity but is not a genus 0 with 3 points.

        INPUT:
        
        - ``a`` -- A list of :class:`~FJRW.FJRWBasisElement` s.
        - ``verbose`` -- Set this to ``True`` to get output about which axiom
          was used. Defaults to ``False``.
        - ``g`` -- The genus of the correlator. Defaults to 0.

        OUTPUT:
        
        - ``True`` if the correlator vanishes by any of the selection rules
          described above. ``False`` if none of them apply.
        
        .. TODO::
        
            Add tests.
        
        """
        def vprint(message):
            if verbose:
                print(message)

        k = len(a)

#   --Contains the identity but is not a pairing.
        if not (g == 0 and k == 3):
            for ai in a:
                if ai.is_one():
                    vprint("This correlator contains the identity, but is not "
                           "a pairing, so the class will be the wrong "
                           "dimension.")
                    return True

#   --Dimension Axiom--
        sum_degrees = sum([ai.degree for ai in a])

        D = (self.singularity.central_charge * (g - 1) + Rational((1, 2)) *
             sum_degrees)


        if 2 * D not in ZZ:
            vprint("Dimension is %(D)s -- not in 2Z. Correlator vanishes."
                   % locals())
            return True
        
        dimension_comparison_value = 3 * g - 3 + k
        if D != dimension_comparison_value:
            vprint("The dimension is %(D)s, not equal to 3g - 3 + k = "
                   "%(dimension_comparison_value)s. Vanishes by dimension "
                   "axiom." % locals())
            return True

#   --Integer Degree Axiom--
        l = self.line_bundle_degrees(a, g)
        for j in range(0, self.singularity.nvariables):
            if not l[j] in ZZ:
                vprint("0 by Integer line bundle degree axiom. The degrees "
                       "are %(l)s." % locals())
                return True

#   --Action of Gmax Property--
        Gmax = SymmetryGroup(self.Gsec.poly, "max")

        for g in Gmax.gens():
            action = sum([g.log_action(ai) for ai in a])
            if action not in ZZ:
                vprint("Vanishes by action of %(g)s. The action was %(action)s"
                       % locals())
                return True
        
        # Nothing applies.
        return False
        
    def RRD(self, a, g=0):
        """
        Return Riemann-Roch degree of a certain correlator.
        
        INPUT:
        
        - ``a`` -- A list of :class:`~FJRW.FJRWBasisElement` s in a correlator.
        - ``g`` -- The genus of a correlator. Defaults to 0.
        
        OUTPUT:
        
        - The Reimann Roch Degree.
        
        .. TODO::
        
            Add tests.
        
        """
        D = 0
        for i in range(self.singularity.nvariables):
            D -= self.line_bundle_degrees(a, g)[i] - g + 1
        return D
    
    def line_bundle_degrees(self, a, g=0):
        """
        Return the line bundle degrees of the given correlator.
        
        INPUT:
        
        - ``a`` -- A list of :class:`~FJRW.FJRWBasisElement` s in a correlator.
        - ``g`` -- The genus of the correlator. Defaults to 0.

        OUTPUT:
        
        - A list of rational numbers representing the degrees of the line
          bundles.
        
        .. TODO::
        
            Add tests.
        
        """
        k = len(a)
        q = self.singularity.q
        
        l = [(2 * g - 2 + k) * q[i] - sum([aj.sector[i] for aj in a])
             for i in range(0, self.singularity.nvariables)]
             # TODO: decide what N this is.
        return l
        
    def add_to_corr_dict(self, k):
        """
        Adds values of correlators with ``k`` insertions to the correlator
        dictionary.
        
        INPUT:
        
        - ``k`` -- An integer giving the number of insertions for the
          correlators we want to compute.
        
        Does not return a value.
        
        .. TODO::
        
            Add tests or eliminate by incorporating into
            :meth:`~FJRW.FJRWRing.corr`, which already records computed
            correlators.
        
        """
        if k in self.corrs_calculated:
            pass
        else:
            self.corrs_calculated.append(k)
            for multi_index in Combinations(list(range(1, self.dimension() + 1)) * k,
                                            k):
                try:
                    a = [self[index] for index in multi_index]
                    c = self.corr(a, shortcut=False)
                    corrstring = "<A[" + str(multi_index[0])
                    for i in range(1, k):
                        corrstring += "], A[" + str(multi_index[i])
                    corrstring += "]>"
                    self.corr_dict[corrstring] = c
                except CouldNotComputeException as e:
                    pass
                
    def compute_all_algebra_corr(self, verbose=1):
        """
        Attempts to compute all the three point genus 0 correlators in this FJRW
        ring.
        
        INPUT:
        
        - ``verbose`` -- An integer representing the level of output desired:
        
          * = ``0`` -- Only print the number successfully computed and number
            failed.
          * = ``1`` -- Print out the value of the non-zero ones and the method
            used.
          * = ``2`` -- Always compute with the ``corr`` verbose option, so you
            get output about every correlator.
          * = ``3`` -- Print out the values of the non-zero ones.
            
          Defaults to ``1``.
            
        Does not return a value.
        
        EXAMPLES::
        
            sage: H = FJRWRing(SymmetryGroup(QSingularity.create("L33F44"), [[0,
            ...   0, 1/2, 3/4], [1/4, 1/4, 3/4, 0]]), print_basis=False)
            sage: H.compute_all_algebra_corr(0)
            Successfully computed:   1326   Failed:   4
            sage: H.compute_all_algebra_corr(3)
            < e_(1/4, 1/4, 1/4, 1/4), e_(1/4, 1/4, 1/4, 1/4), e_(3/4, 3/4, 3/4, 3/4) > = 1
            < e_(1/4, 1/4, 1/4, 1/4), e_(1/4, 1/4, 1/4, 3/4), e_(3/4, 3/4, 3/4, 1/4) > = 1
            < e_(1/4, 1/4, 1/4, 1/4), e_(1/4, 1/4, 3/4, 1/2), e_(3/4, 3/4, 1/4, 1/2) > = 1
            < e_(1/4, 1/4, 1/4, 1/4), y^2e_(0, 0, 1/2, 1/4), y^2e_(0, 0, 1/2, 3/4) > = -3/8
            < e_(1/4, 1/4, 1/4, 1/4), y^2e_(0, 0, 1/2, 1/4), x^2e_(0, 0, 1/2, 3/4) > = 1/8
            < e_(1/4, 1/4, 1/4, 1/4), x*ye_(0, 0, 1/2, 1/4), x*ye_(0, 0, 1/2, 3/4) > = 1/8
            < e_(1/4, 1/4, 1/4, 1/4), x^2e_(0, 0, 1/2, 1/4), y^2e_(0, 0, 1/2, 3/4) > = 1/8
            < e_(1/4, 1/4, 1/4, 1/4), x^2e_(0, 0, 1/2, 1/4), x^2e_(0, 0, 1/2, 3/4) > = -3/8
            < e_(1/4, 1/4, 1/4, 1/4), ze_(0, 0, 0, 1/2), x^2*y^2*ze_(0, 0, 0, 1/2) > = 1/32
            < e_(1/4, 1/4, 1/4, 1/4), y*z^2*we_(0, 0, 0, 0), x^2*y*we_(0, 0, 0, 0) > = 1/128
            < e_(1/4, 1/4, 1/4, 1/4), x*z^2*we_(0, 0, 0, 0), x*y^2*we_(0, 0, 0, 0) > = 1/128
            < e_(1/4, 1/4, 1/4, 1/4), e_(1/2, 1/2, 1/2, 1/2), e_(1/2, 1/2, 1/2, 1/2) > = 1
            Failed to compute correlator:  < e_(1/4, 1/4, 1/4, 3/4), y^2e_(0, 0, 1/2, 1/4), y^2e_(0, 0, 1/2, 1/4) >
            Failed to compute correlator:  < e_(1/4, 1/4, 1/4, 3/4), y^2e_(0, 0, 1/2, 1/4), x^2e_(0, 0, 1/2, 1/4) >
            Failed to compute correlator:  < e_(1/4, 1/4, 1/4, 3/4), x*ye_(0, 0, 1/2, 1/4), x*ye_(0, 0, 1/2, 1/4) >
            Failed to compute correlator:  < e_(1/4, 1/4, 1/4, 3/4), x^2e_(0, 0, 1/2, 1/4), x^2e_(0, 0, 1/2, 1/4) >
            Successfully computed:   1326   Failed:   4
        
        """
        failed = 0
        success = 0
        
        for multi_index in Combinations(range(1, self.dimension() + 1) * 3, 3):
            try:
                i, j, k = multi_index
                c = self.corr([self[i], self[j], self[k]], verbose == 2)
                if verbose == 1 and c != 0:
                    self.corr([self[i], self[j], self[k]], verbose=True)
                    print("< " + repr(self[i]) + ", " + repr(self[j]) + ", " +
                           repr(self[k]) +  " > = " + str(c))
                if verbose == 3 and c != 0:
                    print("< " + repr(self[i]) + ", " + repr(self[j]) + ", "
                          + repr(self[k]) + " > = " + str(c))
                success = success + 1
            except CouldNotComputeException as e:
                if verbose >= 1:
                    print("Failed to compute correlator:  < " + repr(self[i])
                          + ", " + repr(self[j]) + ", " + repr(self[k]) +  " >")
                failed = failed + 1
        print("Successfully computed:  ", success, "  Failed:  ", failed)
    
    def unknown_0_3_corrs(self):
        """
        Return a list of unknown genus-0, 3-pt correlators.
        
        OUTPUT:
        
        - A list of lists of :class:`~FJRW.FJRWBasisElement` s representing
          unknown 3-pt correlators.
        
        .. TODO::
        
            Add tests.
        
        """
        unknowns = []
        # Try all possible 3-pt correlators.
        for multi_index in Combinations(range(1, self.dimension() + 1) * 3, 3):
            a = [self[k] for k in multi_index]
            # If corr value can be computed, pass.
            try:
                self.corr(a)
            # Otherwise, append to list of unknowns.
            except CouldNotComputeException:
                unknowns.append(a)
        return unknowns
    
    
############################################################
#
# Methods needed for reconstruction lemma:
#
############################################################
    def last_term(self, a):
        """
        Return missing elements (and their duals) from a k-pt correlator with
        insertions from ``a`` (of length k - 1).
        
        """
        # Length of correlator.
        k = len(a) + 1
        # This calculation comes from line-bundle degree axiom.
        gp = (k - 2) * self[1].sector
        for e in a:
            gp -= e.sector
    
        # Are there any basis elements of A with the appropriate gp element?
        possibles = []
        for i in range(self.dimension()):
            elem = self.list()[i]
            if elem.sector == gp:
                # Attach element delta, and the corresponding element in the
                # dual_basis.
                possibles.append([elem, self.dual_basis[i]])
        return possibles
        
    def corr_eval(self, a, shortcut=False):
        """
        Return a value for a correlator, or the preferred string representation.
        
        """
        # First find string representation.
        corrstring = self.corr_to_basis(a)
        # Try to find correlator value.
        # It might be an algebra element, instead of basis element.
        corrvec = [e.monomial_coefficients().keys() for e in a]
        # list of basis elements
        corrscalar = [list(e.monomial_coefficients().values())[0] for e in a]
        # list of scalars
        m = prod(corrscalar)
        
        try:
            val = m * (self.corr_dict[corrstring])
        # Otherwise return the string.
        except:
            val = "%(m)s*%(corrstring)s" % locals()
        return val
        
    def corr_to_basis(self, a):
        """Return list elements by their indices instead of regular notation"""
        
        l = [e.leading_support().index for e in a]
        # list of indices of first basis elem (support) in each e in a
        l.sort()
        newcorr = "<A[%s]>" % "], A[".join([str(element) for element in l])
        return newcorr
        
    def allcorrs(self, g, k):
        """
        Return a list of 3 lists of genus-``g`` ``k``-point correlators:
        
        #. Those that can be computed w/ concavity axiom.
        #. Those that are still unknown.
        #. Those that are forced to be zero by one of the axioms or properties.
        
        EXAMPLE::
        
            sage: J10 = QSingularity.create("f3c32")
            sage: G = SymmetryGroup(J10, "max")
            sage: H = FJRWRing(G,print_basis=False); H
            FJRW ring for x^3 + y^3*z + z^2 with group generated by <(1/3, 0, 0), (0, 1/6, 1/2)>.
            sage: allcorrs = H.allcorrs(0,4)
            sage: allcorrs[0]
            [[e_(1/3, 1/2, 1/2), e_(1/3, 1/2, 1/2), e_(1/3, 1/2, 1/2), e_(2/3, 5/6, 1/2)], [e_(1/3, 1/2, 1/2), e_(1/3, 1/2, 1/2), e_(1/3, 5/6, 1/2), e_(2/3, 1/2, 1/2)], [e_(1/3, 1/2, 1/2), e_(2/3, 1/6, 1/2), e_(1/3, 5/6, 1/2), e_(1/3, 5/6, 1/2)], [e_(2/3, 1/6, 1/2), e_(2/3, 1/6, 1/2), e_(2/3, 1/6, 1/2), e_(2/3, 5/6, 1/2)], [e_(2/3, 1/6, 1/2), e_(2/3, 1/6, 1/2), e_(2/3, 1/2, 1/2), e_(2/3, 1/2, 1/2)]]
            sage: allcorrs[1]
            [[y^2e_(1/3, 0, 0), y^2e_(1/3, 0, 0), e_(1/3, 1/2, 1/2), e_(2/3, 5/6, 1/2)], [y^2e_(1/3, 0, 0), y^2e_(1/3, 0, 0), e_(1/3, 5/6, 1/2), e_(2/3, 1/2, 1/2)], [y^2e_(1/3, 0, 0), e_(1/3, 1/2, 1/2), e_(1/3, 5/6, 1/2), y^2e_(2/3, 0, 0)], [e_(2/3, 1/6, 1/2), e_(2/3, 1/6, 1/2), y^2e_(2/3, 0, 0), y^2e_(2/3, 0, 0)]]
            
        """
        nonzero = []
        concaves = []
        zeros = []
        
        # Look at all possible correlators.
        for multi_index in Combinations(list(range(1, self.dimension() + 1) )* k, k):
            a = [self[j] for j in multi_index]
            
            # Determine if all insertions are narrow.
            narrow = True
            for i in range(k):
                if len((a[i].sector).fixed) != 0:
                    narrow = False
            
            # If forced to zero, add to zeros list.
            if self.forced_zero(a):
                zeros.append(a)
            
            # Otherwise, if concave and all narrow insertions, add to concaves.
            elif (max(self.line_bundle_degrees(a, g)) < 0 and
                  ModuliSpace(self, a).all_boundary_concave() and narrow):
                concaves.append(a)
            
            # Otherwise, add to unknowns.
            else:
                nonzero.append(a)
                
        #self._update_corrs_file()
        return [concaves, nonzero, zeros]
        
    def reconst(self, a, prod=0, shortcut=True):
        """
        Return an eqn from reconstruction lemma.
    
        INPUT:
        
        - ``a`` -- A list of `k + 1` insertions; reconstruction will use
          `<a[0], ..., a[k - 2], a[k - 1]*a[k]>`.
        - ``prod`` -- (optional) Evaluate a product not determined by
          :class:`~FJRW.FJRWRing.corr` method.
        
        See D_4 Paper.
        
        EXAMPLE::
        
            sage: J10 = QSingularity.create("f3c32")
            sage: G = SymmetryGroup(J10, "max")
            sage: H = FJRWRing( G, print_basis=False ); H
            FJRW ring for x^3 + y^3*z + z^2 with group generated by <(1/3, 0, 0), (0, 1/6, 1/2)>.
            sage: H.reconst([H[4],H[4],H[4],H[2],H[6]])
            '(-1/3)*(1*<A[4], A[4], A[4], A[8]>)== + (1*<A[2], A[2], A[4]>)*(-3*<A[4], A[4], A[6], A[6]>)'
            
            sage: H.add_to_corr_dict(3)
            sage: H.add_to_corr_dict(4)
            sage: H.reconst([H[4],H[4],H[4],H[2],H[6]])
            '(-1/3)*(1/3)== + (1*<A[2], A[2], A[4]>)*(-3*<A[4], A[4], A[6], A[6]>)'
        
        """
        k = len(a) - 1
        gammaab = [a[i] for i in range(k - 3)]
        alpha = a[k - 3]
        beta = a[k - 2]
        #epsilon*psi:
        epsilon = a[k - 1]
        psi = a[k]
        try:
            prod_eps_psi = epsilon * psi
            rescale = prod_eps_psi.leading_coefficient()
            prodelem = prod_eps_psi/rescale
        except:
            if prod != 0:
                prodelem = prod[1]
                rescale = prod[0]
            else:
                print("bad product")
                return str(epsilon) + "*" + str(psi) + "=" + str(epsilon * psi)
        
        #print rescale
    
        #string simplification of rightside of equation
        #(tries to evaluate correlator first)
        c0 = gammaab + [alpha, beta, prodelem]
        rightside = ("(" + str(rescale) + ")*(" +
                     str(self.corr_eval(c0, shortcut=shortcut)) + ")")
    
        #I union J = Kminus 3:
        Kminus3 = [k for k in range(k - 3)]
        #print "Kminus3", Kminus3
        #sums that get added
        plussum = []
        #sums that get subtracted
        minussum = []
        
        #I = p:
        for p in subsets(Kminus3):
            #print p
            a1 = [gammaab[i] for i in p]
            #print "gammaI", a1
            a1corr = a1 + [alpha, epsilon]
            #print "corr1", self.corr_to_basis(a1corr)
            a2 = []
            for k in Kminus3:
                if k not in p:
                    a2.append(gammaab[k])
            #print "gammaJ", a2
            a2corr = a2 + [beta, psi]
            #print "corr2", self.corr_to_basis(a2corr)
            #finds delta, and delta' possibilities:
            d1list = self.last_term(a1corr)
            if len(d1list) > 0:
                for d1 in d1list:
                    plussum.append([a1corr + [d1[0]], a2corr + [d1[1]]])
            if p != Kminus3:
                a3corr = a1 + [alpha, beta]
                a4corr = a2 + [epsilon, psi]
                #finds delta and delta' possibilities:
                d1list = self.last_term(a3corr)
                if len(d1list) > 0:
                    for i in range(len(d1list)):
                        d1 = d1list[i]
                        minussum.append([a3corr + [d1[0]], a4corr + [d1[1]]])
                        
        #string simplification of left side of equation
        #after trying to evaluate all correlators:
        leftside = ""
        for pair in plussum:
            corr1 = self.corr_eval(pair[0], shortcut=shortcut)
            corr2 = self.corr_eval(pair[1], shortcut=shortcut)
            #print self.corr_to_basis(pair[0]), corr1
            #print self.corr_to_basis(pair[1]), corr2
            if corr1 != 0 and corr2 != 0:
                leftside += " + (" + str(corr1) + ")*(" + str(corr2) + ")"
                
        for pair in minussum:
            corr1 = self.corr_eval(pair[0])
            corr2 = self.corr_eval(pair[1])
            #print self.corr_to_basis(pair[0]), corr1
            #print self.corr_to_basis(pair[1]), corr2
            if corr1 != 0 and corr2 != 0:
                leftside += " - (" + str(corr1) + ")*(" + str(corr2) + ")"
                
        if leftside == "":
            leftside += "0"
        #Combine the two sides:
        totaleqn = str(rightside) + "==" + leftside
        try:
            sageeqn = sage_eval(totaleqn, {})
            if not sageeqn:
                print("FALSE", a, sageeqn)
        except:
            pass
        return totaleqn
        
    def important_dicts(self, N):
        """
        Return two important dictionaries
    
        INPUT:
        
        - ``N`` -- The maximum number of insertions in correlators we consider.
        
        OUTPUT:
        
        - A list consisting of two dictionaries:
        
          #. ``vardict`` -- A dictionary sending correlator strings to
             variables.
          #. ``strdict`` -- A dictionary sending strings of variables to
             variables.
        
        """
        #3-point correlators have to be dealt with first:
        #Find a list of all unknown 3-point correlators
        all3 = []
        list3 = self.allcorrs(0,3)[1]
        for corr in list3:
            try:
                self.corr(corr)
            except:
                all3.append(corr)
        all3var = all3
        
        #Change this list to string representations (no scalars)
        all3 = [self.corr_to_basis(corr) for corr in all3]
        
        #Create big list of uknown correlator strings and variables
        unknownstr = all3
        varlist=[]
        
        #initialize 3-point correlator variables and add them to varlist
        for corr in all3var:
            l = [e.index for e in corr]
            strx = 'x'
            for k in range(3):
                strx +='_' + str(l[k])
            var(strx)
            varlist.append(eval(strx))
            
        #For each N > 3,
        #initialize N-point correlator variables, and add them to varlist
        for i in range(4, N + 1):
            #Find a list of unknown correlator values
            allN = self.allcorrs(0, i)
            unknown = allN[1]
            for corr in unknown:
                l = [e.index for e in corr]
                strx = 'x'
                for k in range(len(l)):
                    strx +='_' + str(l[k])
                var(strx)
                varlist.append(eval(strx))
            #Convert these correlators to string representations and add to unknownstr
            unknownstr += [self.corr_to_basis(corr) for corr in unknown]
        
        #create a list of strings of the variables in varlist
        varliststr = [str(v) for v in varlist]
        #dictionary taking correlator strings to variables
        vardict = dict(zip(unknownstr, varlist))
        #dictionary taking variable strings to variables
        strdict = dict(zip(varliststr, varlist))
        
        return [vardict, strdict]


    def reconst_using_product(self, a, b, corrlist, prod=0, shortcut=True):
        """
        Return an list of eqns from reconstruction lemma using a given product and list of corrs.
    
        INPUT:
        
        - ``a, b`` -- FJRW elements used in reconstruction lemma 
                        (a*b will be the final element in any reconstructed correlator) 
        - ``corrlist`` -- a list of correlators which may or may not contain the insertion a*b
                            these are the correlators which the method will attempt to reconstruct
        - ``prod`` -- (optional) use `prod` instead of `a*b` 
                        (useful when a*b is cannot be evaluated in code, but is known)
                        
        EXAMPLE::
        
            sage: J10 = QSingularity.create("f3c32")
            sage: G = SymmetryGroup(J10, "max")
            sage: H = FJRWRing( G, print_basis = False ); H
            FJRW ring for x^3 + y^3*z + z^2 with group generated by <(1/3, 0, 0), (0, 1/6, 1/2)>.
            
            sage: H.add_to_corr_dict(3)
            sage: H.add_to_corr_dict(4)
            sage: allcorrs = H.allcorrs(0,4)
            sage: H.reconst_using_product(H[2],H[6],allcorrs[0])
            [(-1/18) == -x_2_3_5_6, (-1/9) == -3*x_2_2_4*x_4_4_6_6]
        
        See D_4 Paper.
        
        """
        N = len(corrlist[0])
        #If prod=0, find product by multiplying elements a and b
        if prod ==0:
            atimesb = a*b
            #print a, b
            #print atimesb.data.items()
            rescale = atimesb.leading_coefficient()
            ab = atimesb/rescale
            # basis element of atimesb
            #rescale = atimesb.monomial_coefficients()[ab]
            # scalar of atimesb
        #otherwise, use given product
        else:
            ab = prod[1]
            rescale = prod[0]
        #create dictionaries sending correlators to variables and strings:
        vardict = self.important_dicts(N)[0]
        strdict = self.important_dicts(N)[1]
        eqns = []
        productsinlist = []
        # determine which correlators contain our product:
        for corr in corrlist:
            if ab in corr:
                newcorr = list(corr)
                newcorr.remove(ab)
                #permute the (k-1) other insertions:
                for p in Permutations(newcorr):
                    newcorr1 = list(p) + [a, b]
                    productsinlist.append(newcorr1)
        #run reconst on each of correlator in productsinlist
        for corr in productsinlist:
            r =self.reconst(corr, prod = prod)
            eqns.append(r)
        #Change eqns from strings to actual equations with variables
        eqnlist = []
        for eqn in eqns:
            eqna = eqn
            for item in vardict.items():
                if eqna.find(item[0]) != -1:
                    new = eqna.replace(item[0], str(item[1]))
                    eqna = new
            try:
                eqna = sage_eval(eqna, strdict)
                eqna.simplify()
            except:
                pass
            #only add to list if it is new
            if eqna not in eqnlist:
                eqnlist.append(eqna)
        eqns = eqnlist
        return eqns

    
    def _verify_corrs(self, corrs_dict_dict=None):
        """
        Check that the currently computed corrs agree with the values that
        were previously computed and saved. To be run during doctests.
        
        This method checks that the current
        :attr:`~FJRW.FJRWRing._corrs_dict_dict` has no keys that map to
        different values than they did in the version of
        :attr:`~!FJRW.FJRWRing._corrs_dict_dict` that was originally
        loaded by ``self`` on construction.
        
        INPUT:
        
        - ``corrs_dict_dict`` -- A dictionary of the previously computed corrs
          for ``self``. Defaults to the dictionary originally loaded from the
          corrs database.
        
        OUTPUT:
        
        - Raises :class:`AssertionError` if the items in
          :attr:`self._corrs_dict_dict <!FJRW.FJRWRing._corrs_dict_dict>`
          don't agree with the items in ``corrs_dict_dict``. Does not return a
          value.
        
        EXAMPLES::
        
            sage: from LGModels import *
            sage: H = FJRWRing(SymmetryGroup(QSingularity.create("L33"), "max"),
            ...   print_basis=False)
            sage: H._verify_corrs()
            sage: H.products()
            H[2] * H[2] = ???
            ...
            H[6] * H[6] = H[9]
            sage: H.corr([H[1], H[2], H[3], H[6]])
            0
            sage: H._verify_corrs()
        
        Make sure that discrepencies are caught.
        
        .. NOTE::
        
            These tests will only pass if you have previously computed all of
            the correlators mentioned and if you have edited your sage-doctest
            script as explained in the file
            Dropbox/BYU-FJRW-group/report_computation_error_instructions.txt.
        
        ::
            
            sage: H._corrs_dict_dict[(0, 3)][(1, 2, 8)] = 0
            sage: H._corrs_dict_dict[(0, 3)][(3, 5, 5)] = 1/2
            sage: H._corrs_dict_dict[(0, 4)][(1, 2, 3, 6)] = -1/3
            sage: H._verify_corrs()
            Traceback (most recent call last):
            ...
            AssertionError: The following corrs failed for FJRW ring for x^3*y +
            x*y^3 with group generated by <(1/8, 5/8)>:
            (1, 2, 8) was 0 in self._corrs_dict_dict but was previously computed
            as 1.
            (3, 5, 5) was 1/2 in self._corrs_dict_dict but was previously
            computed as 0.
            (1, 2, 3, 6) was -1/3 in self._corrs_dict_dict but was previously
            computed as 0.
            ******...******
            
        Make sure that if an entry is missing from either dictionary, it doesn't
        cause a failure::
        
            sage: del H._corrs_dict_dict[(0, 3)][(1, 2, 8)]
            sage: del H._corrs_dict_dict_orig[(0, 3)][(3, 5, 5)]
            sage: H._corrs_dict_dict[(0, 4)][(1, 2, 3, 6)] = 0
            sage: H._verify_corrs()
        
        The values we've modified here shouldn't be saved, but fix them just in
        case::
        
            sage: H._corrs_dict_dict[(0, 3)][(1, 2, 8)] = 1
            sage: H._corrs_dict_dict[(0, 3)][(3, 5, 5)] = 0
            sage: H._corrs_dict_dict_orig[(0, 3)][(3, 5, 5)] = 0
        
        AUTHOR:
        
        - Scott Mancuso (July 2012)
        
        """
        if corrs_dict_dict is None:
            try:
                corrs_dict_dict = self._corrs_dict_dict_orig
            except AttributeError:
                print("Could not find original corrs_dict_dict.")
                return
        
        failed_corrs = []
        for key, value in self._corrs_dict_dict.items():
            if key == "index":
                # It doesn't matter if the `_uncertain_corrs_index` is
                # different.
                continue
            if key not in corrs_dict_dict:
                # No corrs of this type had been computed before, so they can't
                # be wrong.
                continue
            if value == corrs_dict_dict[key]:
                # All corrs of this type are correct.
                continue
            corrs_dict_orig = corrs_dict_dict[key]
            for corr_key, corr_val in value.items():
                if corr_key not in corrs_dict_orig:
                    # This correlator hadn't been computed before, so it can't
                    # be wrong.
                    continue
                try:
                    assert corr_val == corrs_dict_orig[corr_key], (
                            "%s was %s in self._corrs_dict_dict but was "
                            "previously computed as %s."
                            % (corr_key, corr_val, corrs_dict_orig[corr_key]))
                except (AssertionError, X):
                    failed_corrs.append(X.args[0])
        
        if failed_corrs:
            raise AssertionError ("The following corrs failed for %s:\n"
                                   % str(self).rstrip(".")
                                   + "\n".join(failed_corrs) + "\n" + "*" * 80)

