"""
This module contains:

OrbMilnorElement

OrbMilnorBasisElement
    Attributes:
        degree
        bi_grading
    
OrbMilnorRing
    Methods:
        product_on_basis
    
The OrbMilnorRing class and its associated classes inherit from QuantumRing.
See the beginning of QuantumRing.py for additional explanation of the 
inheritance structure.
    
    
AUTHORS:

    - Drew Johnson (2010-2011) Initial design and implementation
    - Scott Mancuso (2012) Refactoring and documentation
    - Rachel Suggs (2012) Refactoring to inherit from existing Sage objects

"""
# if not __name__ == '__main__':  # i.e. if this is being read as a load or 
                                # attach.
try:
    from sage.all import *
except ImportError:
    print ("Didn't import Sage!!!")

import sys
if "." not in sys.path: sys.path.insert(0,".")

from QuantumRing import QuantumRing, QuantumRingElement, QuantumRingBasisElement
from SymmetryGroup import SymmetryGroup, SymmetryGroupElement
from QSingularity import QSingularity
from LazyAttr import lazy_attr


class OrbMilnorElement(QuantumRingElement):
    """
    Class that represents an element of the orbifold Milnor ring.
    
    .. NOTE::
    
        This class inherits from :class:`QuantumRing.QuantumRingElement`; most of its
        methods and attributes are documented in that class.
    
    CONSTRUCTOR:    
    
    - ``parent`` -- The :class:`~OrbMilnor.OrbMilnorRing` that this basis
      element lives in.
    - ``data`` -- A dictionary of :class:`~OrbMilnor.OrbMilnorBasisElement`\ s and coefficients
    that describes this basis element (I think).
    
    .. NOTE:: 
        
        Users should typically not call the constructor directly. Instead they
        should create an instance of :class:`~OrbMilnor.OrbMilnorRing` which
        will populate a list of :class:`~OrbMilnor.OrbMilnorElement`\ s.
    
    """
    def __init__(self, parent, data):
        """Constructor -- see class documentation."""
        super(OrbMilnorElement, self).__init__(parent, data)
    

class OrbMilnorBasisElement(QuantumRingBasisElement):
    """
    Class that represents a basis element of the orbifold Milnor ring.
    
    .. NOTE::
    
        This class inherits from :class:`QuantumRing.QuantumRingBasisElement`; most of its
        methods and attributes are documented in that class.
    
    CONSTRUCTOR:
    
    - ``parent_ring`` -- The :class:`~OrbMilnorRing.OrbMilnorRing` to which this basis element belongs.
    - ``monomial`` -- The milnor ring basis element associated with this basis element.
    - ``sector`` -- A :class:`~SymmetryGroup.SymmetryGroupElement` associated to this
        basis element.
    
    .. NOTE::
    
        Elements of this class are basis elements for an OrbMilnorRing. The user
        should not call this constructor directly. In fact, the user should never use
        instances of this class directly. Instead, all elements of an OrbMilnorRing
        will be OrbMilnorElements. See the documentation at the beginning of QuantumRing.py for more details.
    
    """

    def __init__(self, parent_ring, monomial, sector):
        super(OrbMilnorBasisElement, self).__init__(parent_ring, monomial, sector)

    # Method deprecated - Implemented in parent instead (Julian Tay, Dec 2012)
    # @lazy_attr
    # def degree(self):
        # """
        # Return the degree of this :class:`~OrbMilnor.OrbMilnorBasisElement`.
        
        # OUTPUT:
        
        # - A rational number giving the degree of this
          # :class:`~!OrbMilnor.OrbMilnorBasisElement`.
        
        # .. NOTE::
        
            # This is the `\mathbb Q`-degree that grades the multiplication and
            # corresponds to the A-model `W`-degree.
            
            # sage: W = QSingularity.create("C78")
            # sage: G = SymmetryGroup(W, [[1/2,1/2]])
            # sage: B = OrbMilnorRing(G)
            # Orbifold Milnor ring for x^7*y + y^8 with group generated by <(1/2, 1/2)>.
            # Dimension:   26
            # Basis:
              # [1]  b_(0, 0)         Degree: 0    (0, 0)
              # [2]  y^2b_(0, 0)      Degree: 1/2  (1/4, 1/4)
              # [3]  x*yb_(0, 0)      Degree: 1/2  (1/4, 1/4)
              # [4]  x^2b_(0, 0)      Degree: 1/2  (1/4, 1/4)
              # [5]  y^4b_(0, 0)      Degree: 1    (1/2, 1/2)
            # ...
            # sage: B[1].degree
            # 0
            # sage: B[2].degree
            # 1/2
            # sage: B[5].degree
            # 1
            
            
        
        # """
        
        # q = self.parent_ring.singularity.q
        # N = len(q)
        # if self.monomial in CC:
            # expon = [0] * N
        # else:
            # expon = self.monomial.exponents()[0]
        # alpha = []
        # for i in xrange(0, N):
            # if i in self.sector.fixed:
                # alpha.append(q[i] * expon[i])
            # else:
                # alpha.append(-1 * q[i])
        # return N - len(self.sector.fixed) + 2 * sum(alpha)
        
    @lazy_attr
    def bi_degree(self):
        """
        Return the bi-degree of this :class:`~OrbMilnor.OrbMilnorBasisElement`.
        
        OUTPUT:
        
        - A tuple of rational numbers giving the bigrading of this
          :class:`~!OrbMilnor.OrbMilnorBasisElement`.
        
        .. NOTE::
        
            The calculation for the bi-grading is given on page 13 of [Kr]_.
        
        EXAMPLES:
        
            sage: W = QSingularity.create("C223")
            sage: G = SymmetryGroup(W, [[1/3,1/3,1/3]])
            sage: B = OrbMilnorRing(G)
            Orbifold Milnor ring for x^2*y + y^2*z + z^3 with group generated by <(1/3, 1/3, 1/3)>.
            Dimension:   4
            Basis:
              [1]  b_(0, 0, 0)        Degree: 0  (0, 0)
              [2]  b_(1/3, 1/3, 1/3)  Degree: 1  (0, 1)
              [3]  b_(2/3, 2/3, 2/3)  Degree: 1  (1, 0)
              [4]  y*z^2b_(0, 0, 0)   Degree: 2  (1, 1)
            sage: B[2].bi_degree
            (0, 1)
            sage: B[3].bi_degree
            (1, 0)
            sage: B[4].bi_degree
            (1, 1)
            
        """
        p_degree = 0
        m_degree = 0
        weights = self.parent_ring.Gsec.poly.q
        group_elem = self.sector
        
        for n in group_elem.not_fixed:
            p_degree += group_elem[n] - weights[n]
            m_degree += 1 - group_elem[n] - weights[n]
        try:
            # Add weighted degree of monomial.
            weighted_degree = sum([e * q for (e, q) in 
                                   zip(self.monomial.exponents()[0], 
                                       weights)])
        except AttributeError:
            # If there was an attribute error, assume it was because the
            # monomial was 1, in which case the weighted degree was 0.
            weighted_degree = 0
        
        p_degree += weighted_degree
        m_degree += weighted_degree
        
        return (p_degree, m_degree)
        
        
class OrbMilnorRing(QuantumRing):
    r"""
    Class that stores infomation about the orbifold Milnor ring for a given
    polynomial and group.
    
    .. NOTE::
    
        This class inherits from :class:`QuantumRing.QuantumRing`; most of its
        methods and attributes are documented in that class.
    
    CONSTRUCTOR:
    
    - ``Gsec`` -- The :class:`~SymmetryGroup.SymmetryGroup` that will create the
      sectors. It must be contained in `SL_n`.
    - ``Ginv`` -- The :class:`~SymmetryGroup.SymmetryGroup` to take invariants
      by. This is a special feature; typically one can leave it blank and then
      it will be set equal to ``Gsec``.
    - ``print_basis`` -- Set this to ``True`` if you want a summary of the state
      space printed immediately after construction. Defaults to ``True``.
    - ``R`` -- The base ring of this algebra. Must be a field. Defaults to "QQ".
    - ``prefix`` -- A string that is the name of this ring. Defaults to "B".
    - ``basis_element_repr`` -- A string used when printing out basis elements 
      of this class. Defaults to "b".

    EXAMPLES:
    
    First, create the necessary objects. Here we use the singularity `W = x^4
    + y^4 + z^2 + w^2`, with `G = \langle \left(0, 0, \frac{1}{2},
    \frac{1}{2}\right) , \left(\frac{1}{4}, \frac{1}{4}, 0, \frac{1}{2}\right)
    \rangle`::
    
        sage: W = QSingularity.create("F4422")
        sage: G = SymmetryGroup(W, [[0, 0, 1/2, 1/2], [1/4, 1/4, 1/2, 0]])
    
    Now construct the orbifold Milnor ring. The object `G` remembers `W`, so
    just pass in `G`::
    
        sage: B = OrbMilnorRing(G)
        Orbifold Milnor ring for x^4 + y^4 + z^2 + w^2 with group generated by
        <(0, 0, 1/2, 1/2), (1/4, 1/4, 0, 1/2)>.
        Dimension:   6
        Basis:
          [1]  b_(0, 0, 0, 0)          Degree: 0     (0, 0)
          [2]  y^2b_(0, 0, 1/2, 1/2)   Degree: 1     (1/2, 1/2)
          [3]  x*yb_(0, 0, 1/2, 1/2)   Degree: 1     (1/2, 1/2)
          [4]  x^2b_(0, 0, 1/2, 1/2)   Degree: 1     (1/2, 1/2)
          [5]  b_(1/2, 1/2, 1/2, 1/2)  Degree: 1     (1/2, 1/2)
          [6]  x^2*y^2b_(0, 0, 0, 0)   Degree: 2     (1, 1)
    
    Use ``[ ]`` to access basis elements by index::
    
        sage: a = B[4]; a
        x^2b_(0, 0, 1/2, 1/2)
        sage: b = B[3]; b
        x*yb_(0, 0, 1/2, 1/2)
    
    You can multiply basis elements::
    
        sage: B[1] * B[6]
        x^2*y^2b_(0, 0, 0, 0)
        sage: B[4] * B[2]
        4*x^2*y^2b_(0, 0, 0, 0)
        sage: B[5] * B[5]
        64*x^2*y^2b_(0, 0, 0, 0)
        sage: B[3] * B[4]
        0
        sage: B[6] * B[2]
        0
        sage: B[3] * B[5]
        0
    
    Vector space operations are supported::
    
        sage: c = 8*a + 5*b; c
        5*x*yb_(0, 0, 1/2, 1/2) + 8*x^2b_(0, 0, 1/2, 1/2)
    
    You can also access elements by their names. The name must be typed exactly
    as it appears in the list::
    
        sage: a = B["b_(1/2, 1/2, 1/2, 1/2)"]
        sage: a
        b_(1/2, 1/2, 1/2, 1/2)
    
    Algebra operations are supported::
    
        sage: a = B[1] + 3 * B[5]; a
        b_(0, 0, 0, 0) + 3*b_(1/2, 1/2, 1/2, 1/2)
        
        sage: b = a * B[5]; b
        b_(1/2, 1/2, 1/2, 1/2) + 192*x^2*y^2b_(0, 0, 0, 0)
        
        sage: b * (1/2)
        1/2*b_(1/2, 1/2, 1/2, 1/2) + 96*x^2*y^2b_(0, 0, 0, 0)
        
        sage: b - 2*a
        -2*b_(0, 0, 0, 0) - 5*b_(1/2, 1/2, 1/2, 1/2) + 192*x^2*y^2b_(0, 0, 0, 0)
    
    The orbifold group must be contained in `SL_n`::
    
        sage: Gbad = SymmetryGroup(W, "max")
        sage: Bbad = OrbMilnorRing(Gbad)
        Traceback (most recent call last):
        ...
        ValueError: The orbifold group must be contained in SL!
    
    Here are three more examples of LG Mirror Symmetry B-Model state space construction
    
        sage: W = QSingularity.create("C56")
        sage: G = SymmetryGroup(W, [[3/6,3/6]])
        sage: B = OrbMilnorRing(G)
        Orbifold Milnor ring for x^5*y + y^6 with group generated by <(1/2, 1/2)>.
        Dimension:   14
        Basis:
          [1]  b_(0, 0)         Degree: 0    (0, 0)
          [2]  y^2b_(0, 0)      Degree: 2/3  (1/3, 1/3)
          [3]  x*yb_(0, 0)      Degree: 2/3  (1/3, 1/3)
          [4]  x^2b_(0, 0)      Degree: 2/3  (1/3, 1/3)
          [5]  y^4b_(0, 0)      Degree: 4/3  (2/3, 2/3)
          [6]  x*y^3b_(0, 0)    Degree: 4/3  (2/3, 2/3)
          [7]  x^2*y^2b_(0, 0)  Degree: 4/3  (2/3, 2/3)
          [8]  x^3*yb_(0, 0)    Degree: 4/3  (2/3, 2/3)
          [9]  x^4b_(0, 0)      Degree: 4/3  (2/3, 2/3)
         [10]  b_(1/2, 1/2)     Degree: 4/3  (2/3, 2/3)
         [11]  x*y^5b_(0, 0)    Degree: 2    (1, 1)
         [12]  x^2*y^4b_(0, 0)  Degree: 2    (1, 1)
         [13]  x^3*y^3b_(0, 0)  Degree: 2    (1, 1)
         [14]  x^3*y^5b_(0, 0)  Degree: 8/3  (4/3, 4/3)
         
        sage: W = QSingularity.create("C226")
        sage: G = SymmetryGroup(W, [[1/3,1/3,1/3]])
        sage: B = OrbMilnorRing(G)
        Orbifold Milnor ring for x^2*y + y^2*z + z^6 with group generated by <(1/3, 1/3, 1/3)>.
        Dimension:   7
        Basis:
          [1]  b_(0, 0, 0)        Degree: 0    (0, 0)
          [2]  z^3b_(0, 0, 0)     Degree: 1    (1/2, 1/2)
          [3]  b_(1/3, 1/3, 1/3)  Degree: 5/4  (1/8, 9/8)
          [4]  x*z^2b_(0, 0, 0)   Degree: 5/4  (5/8, 5/8)
          [5]  b_(2/3, 2/3, 2/3)  Degree: 5/4  (9/8, 1/8)
          [6]  y*z^2b_(0, 0, 0)   Degree: 3/2  (3/4, 3/4)
          [7]  y*z^5b_(0, 0, 0)   Degree: 5/2  (5/4, 5/4)
          
        sage: W = QSingularity.create("RC352")
        sage: G = SymmetryGroup(W, [[1/3,1/3,1/3]])
        sage: B = OrbMilnorRing(G)
        Orbifold Milnor ring for x^3 + x*y^5 + y*z^2 with group generated by <(1/3, 1/3, 1/3)>.
        Dimension:   7
        Basis:
          [1]  b_(0, 0, 0)         Degree: 0     (0, 0)
          [2]  y^3b_(0, 0, 0)      Degree: 4/5   (2/5, 2/5)
          [3]  b_(1/3, 1/3, 1/3)   Degree: 6/5   (1/10, 11/10)
          [4]  x*y^2b_(0, 0, 0)    Degree: 6/5   (3/5, 3/5)
          [5]  b_(2/3, 2/3, 2/3)   Degree: 6/5   (11/10, 1/10)
          [6]  x^2*yb_(0, 0, 0)    Degree: 8/5   (4/5, 4/5)
          [7]  x^2*y^4b_(0, 0, 0)  Degree: 12/5  (6/5, 6/5)


    
    AUTHORS:
    
    - Drew Johnson (2010-2011)
    
      - Initial implementation
    
    - Scott Mancuso (2012)
    
      - Documentation
    
    """
    Element = OrbMilnorElement
    """An alias for the class of elements of this ring."""
    _my_basis_element = OrbMilnorBasisElement
    """An alias for the class of basis elements of this ring."""
    _ring_type = "Orbifold Milnor ring"
    """A string describing the type of ring that this is."""

    def __init__(self, Gsec, Ginv="default", print_basis = True, R = QQ, prefix = "B", basis_element_repr = "b"):
        """Constructor -- see class documentation."""
        
        # First check that the orbifold group is contained in SL
        if Ginv =="default":
            if not Gsec.contained_in_SL():
                raise ValueError( "The orbifold group must be contained in SL!")
        else:
            if not Ginv.contained_in_SL():
                raise ValueError( "The orbifold group must be contained in SL!")
                
        super(OrbMilnorRing, self).__init__(Gsec, Ginv, print_basis, R, prefix, basis_element_repr)
        
    def product_on_basis(self, x, y):
        """
        Return the product of ``x`` and ``y``.
        
        INPUT:
        
        - ``a, b`` -- Two :class:`~!OrbMilnor.OrbMilnorBasisElement`\ s that are in the basis of self.
        
        OUTPUT:
        
        - The value of the product of ``x`` and ``y``.
        
        .. NOTE::
            
            This method is called by the method :meth:`~QuantumRing.QuantumRing.pair`.
            It should not be called directly by the user.
            
        .. TODO::
        
            Add tests.
            
        """
        indices = tuple(sorted([x.index, y.index]))
        # Has the value already been computed?
        try:
            value = self._products_dict[indices]
        except KeyError:
            # Compute the pairing of these two elements while we're at it.
            # self.pair(x, y)
        
            g = x.sector
            h = y.sector
            gh  = g + h
            
            all_indices = g.parent().identity().fixed
            if not g.fixed.union(h.fixed).union(gh.fixed) == all_indices:
                value = self.zero()
            elif len(gh.fixed) == 0:
                if x.monomial * y.monomial not in self.base_ring():
                    value = self.zero()
                else:
                    value = self.basis()[self._my_basis_element(self, 1, gh)]
            else:
                Wgh = self.singularity.restrict(gh.fixed)
                g_cap_h_fixed = g.fixed.intersection(h.fixed)
                Wg_cap_h = self.singularity.restrict(g_cap_h_fixed)
        
                hessgh = Wgh.hessian_det()
                hessg_cap_h = Wg_cap_h.hessian_det()
        
                R = Wgh.milnor_ring_ring
        
                proj = R.cover()
                p_monom = ((proj(hessgh) / proj(hessg_cap_h)) * x.monomial * 
                           y.monomial  * Wg_cap_h.mu / Wgh.mu)
        
                if p_monom == 0 or not ( 
                            set(p_monom.variables()).issubset(set([R.gen(i) for i in 
                                                                   gh.fixed]))):
                    value = self.zero()
            
                # Is this a bad workaround?  But we would like to keep everything
                # expressed in the same basis.
                for m in Wgh.milnor_ring:
                    if p_monom.lm() == proj(m).lm():
                        coeff = p_monom.lc()/proj(m).lc()
                        value = coeff*self.basis()[self._my_basis_element(self,m, gh)]

            # Record this product.
            self._products_dict[indices] = value
        return value


"""
   The Isomorphism Finder (v. 2.0)

   Author:  Nathan Cordner, 2014-2015

"""

def construct_map(B1,B2, type="diagonal", mathematica=False):
    """
        Currently implemented types:
        'diagonal' -- default, constructs diagonal matrix
        'upper_triangular' -- constructs an upper triangular matrix
        'lower_triangular" -- constructs a lower triangular matrix
        'full' -- uses all possible linear combinations

        TODO:  Add permutation option to diagonal matrix

        Setting 'mathematica' to True will make the computer print out
        code that will run in Wolfram Mathematica to solve the resulting
        system of equations. However, I currently do not know of any 
        examples where Mathematica succeeded when Sage failed...        
    """

    #First verify vector space isomorphism
    if not check_graded_vspace(B1,B2):
        return    
    d = B1.dimension() #Let d be dimension (of both B1 and B2)

    sectors = find_graded_sectors(B1)
    product_relations = find_product_relations(B1) 

    # create d^2 variables to use
    cc = list(var('c%d' % i) for i in range(0,d**2))
    counter = 0
    hom = matrix(SR,d) #SR is for Symbolic Ring

    if type == "upper_triangular":
        hom, counter = upper_triangular_hom(B2, d, cc, sectors, product_relations)
    elif type == "lower_triangular":
        hom, counter = lower_triangular_hom(B2, d, cc, sectors, product_relations)
    elif type == "full":
        hom, counter = full_hom(B2, d, cc, sectors, product_relations)
    else:
        hom, counter = diagonal_hom(B2, d, cc, sectors, product_relations)    
        
    print("using map: " )
    print(str(hom)   )

    compute_isomorphism(B1,B2,hom,cc,counter,product_relations,mathematica)


#the following methods are subroutines for the isomorphism calculators
def check_graded_vspace(B1,B2):
    """
        Subroutine to verify that 
        B1,B2 are isomorphic as graded
        vector spaces
    """
    d1 = B1.dimension()
    d2 = B2.dimension()
    if not (d1 == d2):
        print( "Dimensions do not match")
        return False

    for i in range(1, d1+1):
        if not (B1[i].bi_degree == B2[i].bi_degree):
            print( "Graded sectors do not match")
            return False

    print( "Isomorphic as Graded Vector Spaces")
    return True


def find_graded_sectors(B1):
    """
    Here we partition B1 into graded pieces
    Basis elements of same degree are put together
    """
    d = B1.dimension()
    sectors = []
    i = 1
    while (i < d+1):
        grading = B1[i].degree
        cur_sector = []
        cur_sector.append(B1[i]) 
        while(i < d):
            if (B1[i+1].degree == grading):
                cur_sector.append(B1[i+1])
                i += 1
            else:
                break
        sectors.append(cur_sector)
        i += 1
    return sectors


def find_product_relations(B1):
    """
    We now organize the multiplication
    this information is stored in the list 'product_relations'
    where product_relations[i] stores a 3-tuple
    (a,b,c) where c * basis element i = basis element a * basis element b
    (using the order on the basis produced by the code)

    Note that product_relations[0] always stores 'None'
    For whatever reason, each B-model indexes by 1 instead of 0...
    """
    d = B1.dimension()
    product_relations = []
    for i in range(0, d+1):
        product_relations.append(None)
    for i in range(2,d+1):
        for j in range(i,d+1):
            elem = B1[i] * B1[j]
            if not (elem == 0):
                relation = (i,j,elem.coefficients()[0])
                num = elem.leading_monomial().index
                #print str(num) +": " + str(relation)
                if (product_relations[num] == None):
                    product_relations[num] = [relation]
                else:
                    product_relations[num].append(relation)
    return product_relations
    #Will now store a list of lists: each number contains a list of product relations


#METHOD 1: A DIAGONAL MATRIX
def diagonal_hom(B2, d, cc, sectors, product_relations):
    counter = 0
    hom = matrix(SR,d) #SR is for Symbolic Ring
    hom[0,0] = 1

    #the trivial B-model may break this code, but who cares?
    for i in range(1, len(sectors)):
        cur_sector = sectors[i]
        first_num = cur_sector[0].index
        for kk in range(len(cur_sector)):
            elem = cur_sector[kk]
            num = elem.index
            if (product_relations[num] == None):                
                hom[num-1,num-1] = cc[counter]         
                counter += 1
            else:
                #i.e. compute f(xi) = f(c*xj *xk) = c*f(xj)*f(xk) 
                item = product_relations[num][0]
                product_row = mult_with_symbolic_ring(B2, hom[item[0]-1],hom[item[1]-1])
                #multiply by the constant c
                product_row[:] = [x*(1/item[2]) for x in product_row] 
                hom[num-1] = product_row
    return hom, counter


#METHOD 2: AN UPPER TRIANGULAR MATRIX
def upper_triangular_hom(B2, d, cc, sectors, product_relations):
    counter = 0
    hom = matrix(SR,d) #SR is for Symbolic Ring
    hom[0,0] = 1

    #the trivial B-model may break this code, but who cares?
    for i in range(1, len(sectors)):
        cur_sector = sectors[i]
        first_num = cur_sector[0].index
        for kk in range(len(cur_sector)):
            elem = cur_sector[kk]
            num = elem.index
            if (product_relations[num] == None):
                for j in range(first_num + kk,first_num+len(cur_sector)):
                    hom[num-1,j-1] = cc[counter]         
                    counter += 1
            else:
                #i.e. compute f(xi) = f(c*xj *xk) = c*f(xj)*f(xk) 
                item = product_relations[num][0]
                product_row = mult_with_symbolic_ring(B2, hom[item[0]-1],hom[item[1]-1])
                #multiply by the constant c
                product_row[:] = [x*(1/item[2]) for x in product_row] 
                hom[num-1] = product_row
    return hom, counter


#METHOD 3: A LOWER TRIANGULAR MATRIX
def lower_triangular_hom(B2, d, cc, sectors, product_relations):
    counter = 0
    hom = matrix(SR,d) #SR is for Symbolic Ring
    hom[0,0] = 1

    #the trivial B-model may break this code, but who cares?
    for i in range(1, len(sectors)):
        cur_sector = sectors[i]
        first_num = cur_sector[0].index
        for kk in range(len(cur_sector)):
            elem = cur_sector[kk]
            num = elem.index
            if (product_relations[num] == None):
                for j in range(first_num,first_num+kk+1):
                    hom[num-1,j-1] = cc[counter]         
                    counter += 1
            else:
                #i.e. compute f(xi) = f(c*xj *xk) = c*f(xj)*f(xk) 
                item = product_relations[num][0]
                product_row = mult_with_symbolic_ring(B2, hom[item[0]-1],hom[item[1]-1])
                #multiply by the constant c
                product_row[:] = [x*(1/item[2]) for x in product_row] 
                hom[num-1] = product_row
    return hom, counter


#METHOD 4: ALL POSSIBLE LINEAR COMBINATIONS
def full_hom(B2, d, cc, sectors, product_relations):
    counter = 0
    hom = matrix(SR,d) #SR is for Symbolic Ring
    hom[0,0] = 1

    #the trivial B-model may break this code, but who cares?
    for i in range(1, len(sectors)):
        cur_sector = sectors[i]
        first_num = cur_sector[0].index
        for kk in range(len(cur_sector)):
            elem = cur_sector[kk]
            num = elem.index
            if (product_relations[num] == None):
                for j in range(first_num,first_num+len(cur_sector)):
                    hom[num-1,j-1] = cc[counter]         
                    counter += 1
            else:
                #i.e. compute f(xi) = f(c*xj *xk) = c*f(xj)*f(xk) 
                item = product_relations[num][0]
                product_row = mult_with_symbolic_ring(B2, hom[item[0]-1],hom[item[1]-1])
                #multiply by the constant c
                product_row[:] = [x*(1/item[2]) for x in product_row] 
                hom[num-1] = product_row
    return hom, counter


def compute_isomorphism(B1,B2,hom,cc,counter,product_relations,mathematica):
    """
        set up equations and solve the isomorphism
    """
    d = B1.dimension()
    equations = set([])
    #set up equations that make product relations equal
    for i in range(2,d+1):
        for j in range(i, d+1):
            elem = B1[i] * B1[j]
            alt_prod = mult_with_symbolic_ring(B2, hom[i-1],hom[j-1])
            if elem == 0:
                eq = 0 == sum(alt_prod)
                equations.add(eq)
            else:
                coeff = elem.leading_coefficient()
                basis_num = elem.leading_monomial().index
                alt_prod[:] = [x*(1/coeff) for x in alt_prod]
                eq = sum(hom[basis_num-1]) == sum(alt_prod)
                equations.add(eq)


    for i in range(0,d):
        for j in range(i,d):
            #Set up equations that respect the pairing
            eq = B1.eta[i,j] == pair_with_symbolic_ring(B2, hom[i], hom[j])
            if not str(eq) == '0 == 0':
                equations.add(eq)

    list_equations = list(equations)

    if not mathematica:
        print( 'Solving equations ' + str(list_equations))
        solution = solve(list_equations,cc[:counter]) 
        print( 'Solution(s):  ' + str(solution))
    else:
        print_mathematica(str(list_equations), cc, counter)


def pair_with_symbolic_ring(B, row1, row2):
    """
    Computes pairing between two non-basis elements in B
    with scalar coefficients in the symbolic ring
    """
    eq = 0
    for i in range(0,len(row1)):
        for j in range(0,len(row2)):
            eq += row1[i]*row2[j]*B.eta[i,j]
    return eq


def mult_with_symbolic_ring(B, row1, row2):
    """
    Try to circumvent implementing full-blown multiplication
    in symbolic ring with sage. Maybe later...
    """
    new_row = [0] * len(row1)

    for i in range(0,len(row1)):
        for j in range(0,len(row1)):
            coeff = row1[i] * row2[j]
            if not coeff == 0:
                elem = B[i+1] * B[j+1]
                if not elem == 0:
                    num = elem.leading_monomial().index
                    new_row[num - 1] += elem.coefficients()[0] * coeff
    return new_row  


def print_mathematica(str_equations, cc, counter):
    """
    Convert sage output into form recognizable by mathematica
    """
    str_equations = "Solve" + str_equations
    str_equations = str_equations.replace(","," &&")
    vars = cc[:counter]
    str_vars = str(vars)
    str_vars = str_vars.replace("[","{")
    str_vars = str_vars.replace("]","}")
    filler = ", " + str_vars + "]"
    str_equations = str_equations.replace("]", filler)
    print("Mathematica Code:")
    print(str_equations)


#Code for verifying isomorphisms
def verify_isomorphism(B1,B2,M):
    """
        Given B-models B1,B2 and a matrix M that defines a map
        from B1 to B2. This is an umbrella method to check
        that the map defined by M is an isomorphism of 
        graded Frobenius algebras

    """

    #Our main concern is that M is invertible, and that
    # M respects products and pairings
    
    # computational robustness may be added by anyone who cares to do so!

    if not M.is_invertible():
        print( "matrix is not invertible!!")
    
    print( "checking products")
    respects_products(B1,B2,M)
    print( "checking pairings")
    respects_pairings(B1,B2,M)


def respects_products(B1,B2,M):
    """
        Given B-models B1,B2 and a matrix M that defines a map
        from B1 to B2, this method checks that the map defined
        by M respects the product structure.

        i.e. show for all basis elements bi, bj in B1, that
        M(bi *_1 bj) = M(bi) *_2 M(bj)
    """

    n = B1.dimension()
    bi = B1[1]
    bj = B1[1]

    for i in range(n):
        bi = B1[i+1]
        for j in range(n):
            bj = B1[j+1]
            
            #Compute Left Hand Side
            prod = bi * bj    #may not be a basis element
            LHS = [0]*n

            if not prod == 0:
                p_index = prod.leading_monomial().index - 1
                p_coeff = prod.leading_coefficient()              

                #Instead of worrying about what basis elements I'm getting,
                #I'll just look at coefficients          
                for k in range(n):
                    LHS[k] = M[p_index][k] * p_coeff #fix row, vary over column
            
            #Compute Right Hand Side
            a1 = [0]*n
            a2 = [0]*n
            for k in range(n):
                a1[k] = M[bi.index-1][k] 
                a2[k] = M[bj.index-1][k] 
            RHS = mult_with_symbolic_ring(B2, a1, a2)

            if not LHS == RHS:
                print( "Failed at " + str(i) + ", " + str(j))
                print( "LHS: " + str(LHS))
                print( "RHS: " + str(RHS))


def respects_pairings(B1,B2,M):
    """
        same idea as before, just with pairings!!!
        
        want to show that <bi, bj>_1 = <M(bi), M(bj)>_2
        for all i,j

    """
    n = B1.dimension()
    
    for i in range(n):
        for j in range(n):
            LHS = B1.eta[i,j] 
            RHS = pair_with_symbolic_ring(B2, M[i], M[j])
            
            if not LHS == RHS:
                print( "Failed at " + str(i + 1) + ", " + str(j + 1))
                print( "LHS: " + str(LHS))
                print( "RHS: " + str(RHS))


"""
    An algorithm to determine which weight systems could
    potentially have a B-model that is isomorphic to a 
    given B-model 

    Note that the algorithm will halt on its own if the
    c-hat of the given B-model is less than 1. 

    (two variables only)

    --Nathan Cordner, June 2015

"""


def potential_weights(G, interrupt = 100):
    """
        INPUT:  some "B-admissible" group G,
                a positive integer to halt the process from time to time
        OUTPUT:  a finite list of weight systems

    """

    #for some reason I can't recover the polynomial and group
    #from the OrbMilnorRing object

    B = OrbMilnorRing(G)
    weights = G.poly.q
    B_dim = B.dimension()
    highest_deg = 2 - 2*weights[0] - 2*weights[1]

    q1, q2 = var('q1,q2')
    i = B_dim
  
 
    while(True):      
        solution = solve([2 - 2*q1 - 2*q2 == highest_deg, (1/q1 - 1)*(1/q2 - 1) == i], q1,q2)

        if not (0 <= float(abs(solution[0][0].rhs())) <= 0.5):
            break
        if not (0 <= float(abs(solution[0][1].rhs())) <= 0.5):
            break

        rational_value = solution[0][0].rhs() in QQ 
        if(rational_value):
            print('Unorbifold dimension = ' + str(i))
            print(solution)

        if (i % interrupt == 0):
            response = input('We have reached ' + str(i) + '. Continue? (y/n)')
            if response == n:
                break 

        i += 1  




